{"version":3,"file":"static/js/vendor.audiobuffer-to-wav.132ed09a7a44c7eeb3cb.js","mappings":"6FAyFA,SAASA,EAAaC,EAAMC,EAAQC,GAClC,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAOE,OAAQD,IACjCH,EAAKK,SAASJ,EAASE,EAAGD,EAAOI,WAAWH,GAEhD,CA7FAI,EAAOC,QACP,SAA2BC,EAAQC,GACjCA,EAAMA,GAAO,CAAC,EAEd,IAKIC,EALAC,EAAcH,EAAOI,iBACrBC,EAAaL,EAAOK,WACpBC,EAASL,EAAIM,QAAU,EAAI,EAC3BC,EAAsB,IAAXF,EAAe,GAAK,GAIjCJ,EADkB,IAAhBC,EAmDN,SAAqBM,EAAQC,GAC3B,IAAIf,EAASc,EAAOd,OAASe,EAAOf,OAChCO,EAAS,IAAIS,aAAahB,GAE1BiB,EAAQ,EACRC,EAAa,EAEjB,KAAOD,EAAQjB,GACbO,EAAOU,KAAWH,EAAOI,GACzBX,EAAOU,KAAWF,EAAOG,GACzBA,IAEF,OAAOX,CACT,CA/DaY,CAAWd,EAAOe,eAAe,GAAIf,EAAOe,eAAe,IAE3Df,EAAOe,eAAe,GAGjC,OAGF,SAAoBC,EAASV,EAAQD,EAAYF,EAAaK,GAC5D,IAAIS,EAAiBT,EAAW,EAC5BU,EAAaf,EAAcc,EAE3BjB,EAAS,IAAImB,YAAY,GAAKH,EAAQrB,OAASsB,GAC/C1B,EAAO,IAAI6B,SAASpB,GAGxBV,EAAYC,EAAM,EAAG,QAErBA,EAAK8B,UAAU,EAAG,GAAKL,EAAQrB,OAASsB,GAAgB,GAExD3B,EAAYC,EAAM,EAAG,QAErBD,EAAYC,EAAM,GAAI,QAEtBA,EAAK8B,UAAU,GAAI,IAAI,GAEvB9B,EAAK+B,UAAU,GAAIhB,GAAQ,GAE3Bf,EAAK+B,UAAU,GAAInB,GAAa,GAEhCZ,EAAK8B,UAAU,GAAIhB,GAAY,GAE/Bd,EAAK8B,UAAU,GAAIhB,EAAaa,GAAY,GAE5C3B,EAAK+B,UAAU,GAAIJ,GAAY,GAE/B3B,EAAK+B,UAAU,GAAId,GAAU,GAE7BlB,EAAYC,EAAM,GAAI,QAEtBA,EAAK8B,UAAU,GAAIL,EAAQrB,OAASsB,GAAgB,GACrC,IAAXX,EA8BN,SAA0BiB,EAAQ/B,EAAQgC,GACxC,IAAK,IAAI9B,EAAI,EAAGA,EAAI8B,EAAM7B,OAAQD,IAAKF,GAAU,EAAG,CAClD,IAAIiC,EAAIC,KAAKC,KAAK,EAAGD,KAAKE,IAAI,EAAGJ,EAAM9B,KACvC6B,EAAOM,SAASrC,EAAQiC,EAAI,EAAQ,MAAJA,EAAiB,MAAJA,GAAY,EAC3D,CACF,CAlCIK,CAAgBvC,EAAM,GAAIyB,GAuB9B,SAAuBO,EAAQ/B,EAAQgC,GACrC,IAAK,IAAI9B,EAAI,EAAGA,EAAI8B,EAAM7B,OAAQD,IAAKF,GAAU,EAC/C+B,EAAOQ,WAAWvC,EAAQgC,EAAM9B,IAAI,EAExC,CAzBIsC,CAAazC,EAAM,GAAIyB,GAGzB,OAAOhB,CACT,CA3CSiC,CAAU/B,EAAQI,EAAQD,EAAYF,EAAaK,EAC5D,C","sources":["webpack://silkforest-web/../../node_modules/audiobuffer-to-wav/index.js"],"sourcesContent":["module.exports = audioBufferToWav\nfunction audioBufferToWav (buffer, opt) {\n  opt = opt || {}\n\n  var numChannels = buffer.numberOfChannels\n  var sampleRate = buffer.sampleRate\n  var format = opt.float32 ? 3 : 1\n  var bitDepth = format === 3 ? 32 : 16\n\n  var result\n  if (numChannels === 2) {\n    result = interleave(buffer.getChannelData(0), buffer.getChannelData(1))\n  } else {\n    result = buffer.getChannelData(0)\n  }\n\n  return encodeWAV(result, format, sampleRate, numChannels, bitDepth)\n}\n\nfunction encodeWAV (samples, format, sampleRate, numChannels, bitDepth) {\n  var bytesPerSample = bitDepth / 8\n  var blockAlign = numChannels * bytesPerSample\n\n  var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample)\n  var view = new DataView(buffer)\n\n  /* RIFF identifier */\n  writeString(view, 0, 'RIFF')\n  /* RIFF chunk length */\n  view.setUint32(4, 36 + samples.length * bytesPerSample, true)\n  /* RIFF type */\n  writeString(view, 8, 'WAVE')\n  /* format chunk identifier */\n  writeString(view, 12, 'fmt ')\n  /* format chunk length */\n  view.setUint32(16, 16, true)\n  /* sample format (raw) */\n  view.setUint16(20, format, true)\n  /* channel count */\n  view.setUint16(22, numChannels, true)\n  /* sample rate */\n  view.setUint32(24, sampleRate, true)\n  /* byte rate (sample rate * block align) */\n  view.setUint32(28, sampleRate * blockAlign, true)\n  /* block align (channel count * bytes per sample) */\n  view.setUint16(32, blockAlign, true)\n  /* bits per sample */\n  view.setUint16(34, bitDepth, true)\n  /* data chunk identifier */\n  writeString(view, 36, 'data')\n  /* data chunk length */\n  view.setUint32(40, samples.length * bytesPerSample, true)\n  if (format === 1) { // Raw PCM\n    floatTo16BitPCM(view, 44, samples)\n  } else {\n    writeFloat32(view, 44, samples)\n  }\n\n  return buffer\n}\n\nfunction interleave (inputL, inputR) {\n  var length = inputL.length + inputR.length\n  var result = new Float32Array(length)\n\n  var index = 0\n  var inputIndex = 0\n\n  while (index < length) {\n    result[index++] = inputL[inputIndex]\n    result[index++] = inputR[inputIndex]\n    inputIndex++\n  }\n  return result\n}\n\nfunction writeFloat32 (output, offset, input) {\n  for (var i = 0; i < input.length; i++, offset += 4) {\n    output.setFloat32(offset, input[i], true)\n  }\n}\n\nfunction floatTo16BitPCM (output, offset, input) {\n  for (var i = 0; i < input.length; i++, offset += 2) {\n    var s = Math.max(-1, Math.min(1, input[i]))\n    output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true)\n  }\n}\n\nfunction writeString (view, offset, string) {\n  for (var i = 0; i < string.length; i++) {\n    view.setUint8(offset + i, string.charCodeAt(i))\n  }\n}\n"],"names":["writeString","view","offset","string","i","length","setUint8","charCodeAt","module","exports","buffer","opt","result","numChannels","numberOfChannels","sampleRate","format","float32","bitDepth","inputL","inputR","Float32Array","index","inputIndex","interleave","getChannelData","samples","bytesPerSample","blockAlign","ArrayBuffer","DataView","setUint32","setUint16","output","input","s","Math","max","min","setInt16","floatTo16BitPCM","setFloat32","writeFloat32","encodeWAV"],"sourceRoot":""}