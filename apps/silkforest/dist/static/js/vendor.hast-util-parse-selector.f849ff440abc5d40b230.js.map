{"version":3,"file":"static/js/vendor.hast-util-parse-selector.f849ff440abc5d40b230.js","mappings":"iIAwBA,MAAMA,EAAS,QAoBR,SAASC,EAAcC,EAAUC,GACtC,MAAMC,EAAQF,GAAY,GAEpBG,EAAQ,CAAC,EACf,IAEIC,EAEAC,EAJAC,EAAQ,EAMZ,KAAOA,EAAQJ,EAAMK,QAAQ,CAC3BT,EAAOU,UAAYF,EACnB,MAAMG,EAAQX,EAAOY,KAAKR,GACpBS,EAAWT,EAAMU,MAAMN,EAAOG,EAAQA,EAAMI,MAAQX,EAAMK,QAE5DI,IACGP,EAEmB,MAAbA,EACTD,EAAMW,GAAKH,EACFI,MAAMC,QAAQb,EAAMc,WAC7Bd,EAAMc,UAAUC,KAAKP,GAErBR,EAAMc,UAAY,CAACN,GANnBN,EAAUM,EASZL,GAASK,EAASJ,QAGhBE,IACFL,EAAWK,EAAM,GACjBH,IAEJ,CAEA,MAAO,CACLa,KAAM,UAENd,QAASA,GAAWJ,GAAkB,MACtCmB,WAAYjB,EACZkB,SAAU,GAEd,C","sources":["webpack://silkforest-web/../../node_modules/hast-util-parse-selector/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n */\n\n/**\n * @template {string} SimpleSelector\n *   Selector type.\n * @template {string} DefaultTagName\n *   Default tag name.\n * @typedef {(\n *   SimpleSelector extends ''\n *     ? DefaultTagName\n *     : SimpleSelector extends `${infer TagName}.${infer Rest}`\n *     ? ExtractTagName<TagName, DefaultTagName>\n *     : SimpleSelector extends `${infer TagName}#${infer Rest}`\n *     ? ExtractTagName<TagName, DefaultTagName>\n *     : SimpleSelector extends string\n *     ? SimpleSelector\n *     : DefaultTagName\n * )} ExtractTagName\n *   Extract tag name from a simple selector.\n */\n\nconst search = /[#.]/g\n\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @template {string} Selector\n *   Type of selector.\n * @template {string} [DefaultTagName='div']\n *   Type of default tag name (default: `'div'`).\n * @param {Selector | null | undefined} [selector]\n *   Simple CSS selector (optional).\n *\n *   Can contain a tag name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param {DefaultTagName | null | undefined} [defaultTagName='div']\n *   Tag name to use if `selector` does not specify one (default: `'div'`).\n * @returns {Element & {tagName: ExtractTagName<Selector, DefaultTagName>}}\n *   Built element.\n */\nexport function parseSelector(selector, defaultTagName) {\n  const value = selector || ''\n  /** @type {Properties} */\n  const props = {}\n  let start = 0\n  /** @type {string | undefined} */\n  let previous\n  /** @type {string | undefined} */\n  let tagName\n\n  while (start < value.length) {\n    search.lastIndex = start\n    const match = search.exec(value)\n    const subvalue = value.slice(start, match ? match.index : value.length)\n\n    if (subvalue) {\n      if (!previous) {\n        tagName = subvalue\n      } else if (previous === '#') {\n        props.id = subvalue\n      } else if (Array.isArray(props.className)) {\n        props.className.push(subvalue)\n      } else {\n        props.className = [subvalue]\n      }\n\n      start += subvalue.length\n    }\n\n    if (match) {\n      previous = match[0]\n      start++\n    }\n  }\n\n  return {\n    type: 'element',\n    // @ts-expect-error: tag name is parsed.\n    tagName: tagName || defaultTagName || 'div',\n    properties: props,\n    children: []\n  }\n}\n"],"names":["search","parseSelector","selector","defaultTagName","value","props","previous","tagName","start","length","lastIndex","match","exec","subvalue","slice","index","id","Array","isArray","className","push","type","properties","children"],"sourceRoot":""}