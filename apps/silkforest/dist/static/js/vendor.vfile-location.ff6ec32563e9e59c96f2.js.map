{"version":3,"file":"static/js/vendor.vfile-location.ff6ec32563e9e59c96f2.js","mappings":"gHAkBO,SAASA,EAASC,GACvB,MAAMC,EAAQC,OAAOF,GAOfG,EAAU,GAEhB,MAAO,CAACC,SA8BR,SAAkBC,GAChB,GACEA,GACsB,iBAAfA,EAAMC,MACW,iBAAjBD,EAAME,SACZC,OAAOC,MAAMJ,EAAMC,QACnBE,OAAOC,MAAMJ,EAAME,QACpB,CACA,KAAOJ,EAAQO,OAASL,EAAMC,MAAM,CAClC,MAAMK,EAAOR,EAAQA,EAAQO,OAAS,GAChCE,EAAMC,EAAKZ,EAAOU,GAClBG,GAAe,IAATF,EAAaX,EAAMS,OAAS,EAAIE,EAAM,EAClD,GAAID,IAASG,EAAK,MAClBX,EAAQY,KAAKD,EACf,CAEA,MAAME,GACHX,EAAMC,KAAO,EAAIH,EAAQE,EAAMC,KAAO,GAAK,GAAKD,EAAME,OAAS,EAElE,GAAIS,EAASb,EAAQE,EAAMC,KAAO,GAAI,OAAOU,CAC/C,CACF,EAnDkBC,QAGlB,SAAiBD,GACf,GAAsB,iBAAXA,GAAuBA,GAAU,GAAKA,GAAUf,EAAMS,OAAQ,CACvE,IAAIQ,EAAQ,EAEZ,OAAa,CACX,IAAIJ,EAAMX,EAAQe,GAElB,QAAYC,IAARL,EAAmB,CACrB,MAAMF,EAAMC,EAAKZ,EAAOE,EAAQe,EAAQ,IACxCJ,GAAe,IAATF,EAAaX,EAAMS,OAAS,EAAIE,EAAM,EAC5CT,EAAQe,GAASJ,CACnB,CAEA,GAAIA,EAAME,EACR,MAAO,CACLV,KAAMY,EAAQ,EACdX,OAAQS,GAAUE,EAAQ,EAAIf,EAAQe,EAAQ,GAAK,GAAK,EACxDF,UAIJE,GACF,CACF,CACF,EAyBF,CAMA,SAASL,EAAKZ,EAAOU,GACnB,MAAMS,EAAKnB,EAAMoB,QAAQ,KAAMV,GACzBW,EAAKrB,EAAMoB,QAAQ,KAAMV,GAC/B,OAAY,IAARW,EAAkBF,GACV,IAARA,GAAaA,EAAK,IAAME,EAAWA,EAChCF,EAAKE,EAAKF,EAAKE,CACxB,C","sources":["webpack://silkforest-web/../../node_modules/vfile-location/lib/index.js"],"sourcesContent":["/**\n * @import {VFile, Value} from 'vfile'\n * @import {Location} from 'vfile-location'\n */\n\n/**\n * Create an index of the given document to translate between line/column and\n * offset based positional info.\n *\n * Also implemented in Rust in [`wooorm/markdown-rs`][markdown-rs].\n *\n * [markdown-rs]: https://github.com/wooorm/markdown-rs/blob/main/src/util/location.rs\n *\n * @param {VFile | Value} file\n *   File to index.\n * @returns {Location}\n *   Accessors for index.\n */\nexport function location(file) {\n  const value = String(file)\n  /**\n   * List, where each index is a line number (0-based), and each value is the\n   * byte index *after* where the line ends.\n   *\n   * @type {Array<number>}\n   */\n  const indices = []\n\n  return {toOffset, toPoint}\n\n  /** @type {Location['toPoint']} */\n  function toPoint(offset) {\n    if (typeof offset === 'number' && offset > -1 && offset <= value.length) {\n      let index = 0\n\n      while (true) {\n        let end = indices[index]\n\n        if (end === undefined) {\n          const eol = next(value, indices[index - 1])\n          end = eol === -1 ? value.length + 1 : eol + 1\n          indices[index] = end\n        }\n\n        if (end > offset) {\n          return {\n            line: index + 1,\n            column: offset - (index > 0 ? indices[index - 1] : 0) + 1,\n            offset\n          }\n        }\n\n        index++\n      }\n    }\n  }\n\n  /** @type {Location['toOffset']} */\n  function toOffset(point) {\n    if (\n      point &&\n      typeof point.line === 'number' &&\n      typeof point.column === 'number' &&\n      !Number.isNaN(point.line) &&\n      !Number.isNaN(point.column)\n    ) {\n      while (indices.length < point.line) {\n        const from = indices[indices.length - 1]\n        const eol = next(value, from)\n        const end = eol === -1 ? value.length + 1 : eol + 1\n        if (from === end) break\n        indices.push(end)\n      }\n\n      const offset =\n        (point.line > 1 ? indices[point.line - 2] : 0) + point.column - 1\n      // The given `column` could not exist on this line.\n      if (offset < indices[point.line - 1]) return offset\n    }\n  }\n}\n\n/**\n * @param {string} value\n * @param {number} from\n */\nfunction next(value, from) {\n  const cr = value.indexOf('\\r', from)\n  const lf = value.indexOf('\\n', from)\n  if (lf === -1) return cr\n  if (cr === -1 || cr + 1 === lf) return lf\n  return cr < lf ? cr : lf\n}\n"],"names":["location","file","value","String","indices","toOffset","point","line","column","Number","isNaN","length","from","eol","next","end","push","offset","toPoint","index","undefined","cr","indexOf","lf"],"sourceRoot":""}