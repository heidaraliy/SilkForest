{"version":3,"file":"static/js/vendor.hastscript.5fe1ed4918b3e108a365.js","mappings":"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","sources":["webpack://silkforest-web/../../node_modules/hastscript/lib/create-h.js","webpack://silkforest-web/../../node_modules/hastscript/lib/svg-case-sensitive-tag-names.js","webpack://silkforest-web/../../node_modules/hastscript/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n *\n * @typedef {import('property-information').Info} Info\n * @typedef {import('property-information').Schema} Schema\n */\n\n/**\n * @typedef {Element | Root} Result\n *   Result from a `h` (or `s`) call.\n *\n * @typedef {number | string} StyleValue\n *   Value for a CSS style field.\n * @typedef {Record<string, StyleValue>} Style\n *   Supported value of a `style` prop.\n * @typedef {boolean | number | string | null | undefined} PrimitiveValue\n *   Primitive property value.\n * @typedef {Array<number | string>} ArrayValue\n *   List of property values for space- or comma separated values (such as `className`).\n * @typedef {ArrayValue | PrimitiveValue} PropertyValue\n *   Primitive value or list value.\n * @typedef {{[property: string]: PropertyValue | Style}} Properties\n *   Acceptable value for element properties.\n *\n * @typedef {number | string | null | undefined} PrimitiveChild\n *   Primitive children, either ignored (nullish), or turned into text nodes.\n * @typedef {Array<ArrayChildNested | Nodes | PrimitiveChild>} ArrayChild\n *   List of children.\n * @typedef {Array<Nodes | PrimitiveChild>} ArrayChildNested\n *   List of children (deep).\n * @typedef {ArrayChild | Nodes | PrimitiveChild} Child\n *   Acceptable child value.\n */\n\nimport {parse as commas} from 'comma-separated-tokens'\nimport {parseSelector} from 'hast-util-parse-selector'\nimport {find, normalize} from 'property-information'\nimport {parse as spaces} from 'space-separated-tokens'\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param {Schema} schema\n *   Schema to use.\n * @param {string} defaultTagName\n *   Default tag name.\n * @param {Array<string> | undefined} [caseSensitive]\n *   Case-sensitive tag names (default: `undefined`).\n * @returns\n *   `h`.\n */\nexport function createH(schema, defaultTagName, caseSensitive) {\n  const adjust = caseSensitive && createAdjustMap(caseSensitive)\n\n  /**\n   * Hyperscript compatible DSL for creating virtual hast trees.\n   *\n   * @overload\n   * @param {null | undefined} [selector]\n   * @param {...Child} children\n   * @returns {Root}\n   *\n   * @overload\n   * @param {string} selector\n   * @param {Properties} properties\n   * @param {...Child} children\n   * @returns {Element}\n   *\n   * @overload\n   * @param {string} selector\n   * @param {...Child} children\n   * @returns {Element}\n   *\n   * @param {string | null | undefined} [selector]\n   *   Selector.\n   * @param {Child | Properties | null | undefined} [properties]\n   *   Properties (or first child) (default: `undefined`).\n   * @param {...Child} children\n   *   Children.\n   * @returns {Result}\n   *   Result.\n   */\n  function h(selector, properties, ...children) {\n    let index = -1\n    /** @type {Result} */\n    let node\n\n    if (selector === undefined || selector === null) {\n      node = {type: 'root', children: []}\n      // Properties are not supported for roots.\n      const child = /** @type {Child} */ (properties)\n      children.unshift(child)\n    } else {\n      node = parseSelector(selector, defaultTagName)\n      // Normalize the name.\n      node.tagName = node.tagName.toLowerCase()\n      if (adjust && own.call(adjust, node.tagName)) {\n        node.tagName = adjust[node.tagName]\n      }\n\n      // Handle props.\n      if (isChild(properties)) {\n        children.unshift(properties)\n      } else {\n        /** @type {string} */\n        let key\n\n        for (key in properties) {\n          if (own.call(properties, key)) {\n            addProperty(schema, node.properties, key, properties[key])\n          }\n        }\n      }\n    }\n\n    // Handle children.\n    while (++index < children.length) {\n      addChild(node.children, children[index])\n    }\n\n    if (node.type === 'element' && node.tagName === 'template') {\n      node.content = {type: 'root', children: node.children}\n      node.children = []\n    }\n\n    return node\n  }\n\n  return h\n}\n\n/**\n * Check if something is properties or a child.\n *\n * @param {Child | Properties} value\n *   Value to check.\n * @returns {value is Child}\n *   Whether `value` is definitely a child.\n */\nfunction isChild(value) {\n  // Never properties if not an object.\n  if (value === null || typeof value !== 'object' || Array.isArray(value)) {\n    return true\n  }\n\n  // Never node without `type`; thatâ€™s the main discriminator.\n  if (typeof value.type !== 'string') return false\n\n  // Slower check: never property value if object or array with\n  // non-number/strings.\n  const record = /** @type {Record<string, unknown>} */ (value)\n  const keys = Object.keys(value)\n\n  for (const key of keys) {\n    const value = record[key]\n\n    if (value && typeof value === 'object') {\n      if (!Array.isArray(value)) return true\n\n      const list = /** @type {Array<unknown>} */ (value)\n\n      for (const item of list) {\n        if (typeof item !== 'number' && typeof item !== 'string') {\n          return true\n        }\n      }\n    }\n  }\n\n  // Also see empty `children` as a node.\n  if ('children' in value && Array.isArray(value.children)) {\n    return true\n  }\n\n  // Default to properties, someone can always pass an empty object,\n  // put `data: {}` in a node,\n  // or wrap it in an array.\n  return false\n}\n\n/**\n * @param {Schema} schema\n *   Schema.\n * @param {Properties} properties\n *   Properties object.\n * @param {string} key\n *   Property name.\n * @param {PropertyValue | Style} value\n *   Property value.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addProperty(schema, properties, key, value) {\n  const info = find(schema, key)\n  let index = -1\n  /** @type {PropertyValue} */\n  let result\n\n  // Ignore nullish and NaN values.\n  if (value === undefined || value === null) return\n\n  if (typeof value === 'number') {\n    // Ignore NaN.\n    if (Number.isNaN(value)) return\n\n    result = value\n  }\n  // Booleans.\n  else if (typeof value === 'boolean') {\n    result = value\n  }\n  // Handle list values.\n  else if (typeof value === 'string') {\n    if (info.spaceSeparated) {\n      result = spaces(value)\n    } else if (info.commaSeparated) {\n      result = commas(value)\n    } else if (info.commaOrSpaceSeparated) {\n      result = spaces(commas(value).join(' '))\n    } else {\n      result = parsePrimitive(info, info.property, value)\n    }\n  } else if (Array.isArray(value)) {\n    result = value.concat()\n  } else {\n    result = info.property === 'style' ? style(value) : String(value)\n  }\n\n  if (Array.isArray(result)) {\n    /** @type {Array<number | string>} */\n    const finalResult = []\n\n    while (++index < result.length) {\n      // Assume no booleans in array.\n      const value = /** @type {number | string} */ (\n        parsePrimitive(info, info.property, result[index])\n      )\n      finalResult[index] = value\n    }\n\n    result = finalResult\n  }\n\n  // Class names (which can be added both on the `selector` and here).\n  if (info.property === 'className' && Array.isArray(properties.className)) {\n    // Assume no booleans in `className`.\n    const value = /** @type {number | string} */ (result)\n    result = properties.className.concat(value)\n  }\n\n  properties[info.property] = result\n}\n\n/**\n * @param {Array<RootContent>} nodes\n *   Children.\n * @param {Child} value\n *   Child.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addChild(nodes, value) {\n  let index = -1\n\n  if (value === undefined || value === null) {\n    // Empty.\n  } else if (typeof value === 'string' || typeof value === 'number') {\n    nodes.push({type: 'text', value: String(value)})\n  } else if (Array.isArray(value)) {\n    while (++index < value.length) {\n      addChild(nodes, value[index])\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children)\n    } else {\n      nodes.push(value)\n    }\n  } else {\n    throw new Error('Expected node, nodes, or string, got `' + value + '`')\n  }\n}\n\n/**\n * Parse a single primitives.\n *\n * @param {Info} info\n *   Property information.\n * @param {string} name\n *   Property name.\n * @param {PrimitiveValue} value\n *   Property value.\n * @returns {PrimitiveValue}\n *   Property value.\n */\nfunction parsePrimitive(info, name, value) {\n  if (typeof value === 'string') {\n    if (info.number && value && !Number.isNaN(Number(value))) {\n      return Number(value)\n    }\n\n    if (\n      (info.boolean || info.overloadedBoolean) &&\n      (value === '' || normalize(value) === normalize(name))\n    ) {\n      return true\n    }\n  }\n\n  return value\n}\n\n/**\n * Serialize a `style` object as a string.\n *\n * @param {Style} value\n *   Style object.\n * @returns {string}\n *   CSS string.\n */\nfunction style(value) {\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {string} */\n  let key\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      result.push([key, value[key]].join(': '))\n    }\n  }\n\n  return result.join('; ')\n}\n\n/**\n * Create a map to adjust casing.\n *\n * @param {Array<string>} values\n *   List of properly cased keys.\n * @returns {Record<string, string>}\n *   Map of lowercase keys to uppercase keys.\n */\nfunction createAdjustMap(values) {\n  /** @type {Record<string, string>} */\n  const result = {}\n  let index = -1\n\n  while (++index < values.length) {\n    result[values[index].toLowerCase()] = values[index]\n  }\n\n  return result\n}\n","export const svgCaseSensitiveTagNames = [\n  'altGlyph',\n  'altGlyphDef',\n  'altGlyphItem',\n  'animateColor',\n  'animateMotion',\n  'animateTransform',\n  'clipPath',\n  'feBlend',\n  'feColorMatrix',\n  'feComponentTransfer',\n  'feComposite',\n  'feConvolveMatrix',\n  'feDiffuseLighting',\n  'feDisplacementMap',\n  'feDistantLight',\n  'feDropShadow',\n  'feFlood',\n  'feFuncA',\n  'feFuncB',\n  'feFuncG',\n  'feFuncR',\n  'feGaussianBlur',\n  'feImage',\n  'feMerge',\n  'feMergeNode',\n  'feMorphology',\n  'feOffset',\n  'fePointLight',\n  'feSpecularLighting',\n  'feSpotLight',\n  'feTile',\n  'feTurbulence',\n  'foreignObject',\n  'glyphRef',\n  'linearGradient',\n  'radialGradient',\n  'solidColor',\n  'textArea',\n  'textPath'\n]\n","/**\n * @typedef {import('./create-h.js').Child} Child\n *   Acceptable child value.\n * @typedef {import('./create-h.js').Properties} Properties\n *   Acceptable value for element properties.\n * @typedef {import('./create-h.js').Result} Result\n *   Result from a `h` (or `s`) call.\n */\n\n// Register the JSX namespace on `h`.\n/**\n * @typedef {import('./jsx-classic.js').Element} h.JSX.Element\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} h.JSX.ElementChildrenAttribute\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} h.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic.js').IntrinsicElements} h.JSX.IntrinsicElements\n */\n\n// Register the JSX namespace on `s`.\n/**\n * @typedef {import('./jsx-classic.js').Element} s.JSX.Element\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} s.JSX.ElementChildrenAttribute\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} s.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic.js').IntrinsicElements} s.JSX.IntrinsicElements\n */\n\nimport {html, svg} from 'property-information'\nimport {createH} from './create-h.js'\nimport {svgCaseSensitiveTagNames} from './svg-case-sensitive-tag-names.js'\n\n// Note: this explicit type is needed, otherwise TS creates broken types.\n/** @type {ReturnType<createH>} */\nexport const h = createH(html, 'div')\n\n// Note: this explicit type is needed, otherwise TS creates broken types.\n/** @type {ReturnType<createH>} */\nexport const s = createH(svg, 'g', svgCaseSensitiveTagNames)\n"],"names":["own","hasOwnProperty","createH","schema","defaultTagName","caseSensitive","adjust","values","result","index","length","toLowerCase","createAdjustMap","selector","properties","children","node","type","child","unshift","tagName","call","value","Array","isArray","record","keys","Object","key","list","item","isChild","addProperty","addChild","content","info","find","Number","isNaN","spaceSeparated","commaSeparated","commaOrSpaceSeparated","join","parsePrimitive","property","concat","push","style","String","finalResult","className","nodes","Error","name","number","boolean","overloadedBoolean","normalize","h","s"],"sourceRoot":""}