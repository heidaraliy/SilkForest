{"version":3,"file":"static/js/vendor.hast-util-from-parse5.e4d29e996d5f73c4f6f3.js","mappings":"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","sources":["webpack://silkforest-web/../../node_modules/hast-util-from-parse5/lib/index.js"],"sourcesContent":["/**\n * @import {ElementData, Element, Nodes, RootContent, Root} from 'hast'\n * @import {DefaultTreeAdapterMap, Token} from 'parse5'\n * @import {Schema} from 'property-information'\n * @import {Point, Position} from 'unist'\n * @import {VFile} from 'vfile'\n * @import {Options} from 'hast-util-from-parse5'\n */\n\n/**\n * @typedef State\n *   Info passed around about the current state.\n * @property {VFile | undefined} file\n *   Corresponding file.\n * @property {boolean} location\n *   Whether location info was found.\n * @property {Schema} schema\n *   Current schema.\n * @property {boolean | undefined} verbose\n *   Add extra positional info.\n */\n\nimport {ok as assert} from 'devlop'\nimport {h, s} from 'hastscript'\nimport {find, html, svg} from 'property-information'\nimport {location} from 'vfile-location'\nimport {webNamespaces} from 'web-namespaces'\n\nconst own = {}.hasOwnProperty\n/** @type {unknown} */\n// type-coverage:ignore-next-line\nconst proto = Object.prototype\n\n/**\n * Transform a `parse5` AST to hast.\n *\n * @param {DefaultTreeAdapterMap['node']} tree\n *   `parse5` tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Nodes}\n *   hast tree.\n */\nexport function fromParse5(tree, options) {\n  const settings = options || {}\n\n  return one(\n    {\n      file: settings.file || undefined,\n      location: false,\n      schema: settings.space === 'svg' ? svg : html,\n      verbose: settings.verbose || false\n    },\n    tree\n  )\n}\n\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {DefaultTreeAdapterMap['node']} node\n *   p5 node.\n * @returns {Nodes}\n *   hast node.\n */\nfunction one(state, node) {\n  /** @type {Nodes} */\n  let result\n\n  switch (node.nodeName) {\n    case '#comment': {\n      const reference = /** @type {DefaultTreeAdapterMap['commentNode']} */ (\n        node\n      )\n      result = {type: 'comment', value: reference.data}\n      patch(state, reference, result)\n      return result\n    }\n\n    case '#document':\n    case '#document-fragment': {\n      const reference =\n        /** @type {DefaultTreeAdapterMap['document'] | DefaultTreeAdapterMap['documentFragment']} */ (\n          node\n        )\n      const quirksMode =\n        'mode' in reference\n          ? reference.mode === 'quirks' || reference.mode === 'limited-quirks'\n          : false\n\n      result = {\n        type: 'root',\n        children: all(state, node.childNodes),\n        data: {quirksMode}\n      }\n\n      if (state.file && state.location) {\n        const document = String(state.file)\n        const loc = location(document)\n        const start = loc.toPoint(0)\n        const end = loc.toPoint(document.length)\n        // Always defined as we give valid input.\n        assert(start, 'expected `start`')\n        assert(end, 'expected `end`')\n        result.position = {start, end}\n      }\n\n      return result\n    }\n\n    case '#documentType': {\n      const reference = /** @type {DefaultTreeAdapterMap['documentType']} */ (\n        node\n      )\n      result = {type: 'doctype'}\n      patch(state, reference, result)\n      return result\n    }\n\n    case '#text': {\n      const reference = /** @type {DefaultTreeAdapterMap['textNode']} */ (node)\n      result = {type: 'text', value: reference.value}\n      patch(state, reference, result)\n      return result\n    }\n\n    // Element.\n    default: {\n      const reference = /** @type {DefaultTreeAdapterMap['element']} */ (node)\n      result = element(state, reference)\n      return result\n    }\n  }\n}\n\n/**\n * Transform children.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Array<DefaultTreeAdapterMap['node']>} nodes\n *   Nodes.\n * @returns {Array<RootContent>}\n *   hast nodes.\n */\nfunction all(state, nodes) {\n  let index = -1\n  /** @type {Array<RootContent>} */\n  const results = []\n\n  while (++index < nodes.length) {\n    // Assume no roots in `nodes`.\n    const result = /** @type {RootContent} */ (one(state, nodes[index]))\n    results.push(result)\n  }\n\n  return results\n}\n\n/**\n * Transform an element.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {DefaultTreeAdapterMap['element']} node\n *   `parse5` node to transform.\n * @returns {Element}\n *   hast node.\n */\nfunction element(state, node) {\n  const schema = state.schema\n\n  state.schema = node.namespaceURI === webNamespaces.svg ? svg : html\n\n  // Props.\n  let index = -1\n  /** @type {Record<string, string>} */\n  const properties = {}\n\n  while (++index < node.attrs.length) {\n    const attribute = node.attrs[index]\n    const name =\n      (attribute.prefix ? attribute.prefix + ':' : '') + attribute.name\n    if (!own.call(proto, name)) {\n      properties[name] = attribute.value\n    }\n  }\n\n  // Build.\n  const x = state.schema.space === 'svg' ? s : h\n  const result = x(node.tagName, properties, all(state, node.childNodes))\n  patch(state, node, result)\n\n  // Switch content.\n  if (result.tagName === 'template') {\n    const reference = /** @type {DefaultTreeAdapterMap['template']} */ (node)\n    const pos = reference.sourceCodeLocation\n    const startTag = pos && pos.startTag && position(pos.startTag)\n    const endTag = pos && pos.endTag && position(pos.endTag)\n\n    // Root in, root out.\n    const content = /** @type {Root} */ (one(state, reference.content))\n\n    if (startTag && endTag && state.file) {\n      content.position = {start: startTag.end, end: endTag.start}\n    }\n\n    result.content = content\n  }\n\n  state.schema = schema\n\n  return result\n}\n\n/**\n * Patch positional info from `from` onto `to`.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {DefaultTreeAdapterMap['node']} from\n *   p5 node.\n * @param {Nodes} to\n *   hast node.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(state, from, to) {\n  if ('sourceCodeLocation' in from && from.sourceCodeLocation && state.file) {\n    const position = createLocation(state, to, from.sourceCodeLocation)\n\n    if (position) {\n      state.location = true\n      to.position = position\n    }\n  }\n}\n\n/**\n * Create clean positional information.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Nodes} node\n *   hast node.\n * @param {Token.ElementLocation} location\n *   p5 location info.\n * @returns {Position | undefined}\n *   Position, or nothing.\n */\nfunction createLocation(state, node, location) {\n  const result = position(location)\n\n  if (node.type === 'element') {\n    const tail = node.children[node.children.length - 1]\n\n    // Bug for unclosed with children.\n    // See: <https://github.com/inikulin/parse5/issues/109>.\n    if (\n      result &&\n      !location.endTag &&\n      tail &&\n      tail.position &&\n      tail.position.end\n    ) {\n      result.end = Object.assign({}, tail.position.end)\n    }\n\n    if (state.verbose) {\n      /** @type {Record<string, Position | undefined>} */\n      const properties = {}\n      /** @type {string} */\n      let key\n\n      if (location.attrs) {\n        for (key in location.attrs) {\n          if (own.call(location.attrs, key)) {\n            properties[find(state.schema, key).property] = position(\n              location.attrs[key]\n            )\n          }\n        }\n      }\n\n      assert(location.startTag, 'a start tag should exist')\n      const opening = position(location.startTag)\n      const closing = location.endTag ? position(location.endTag) : undefined\n      /** @type {ElementData['position']} */\n      const data = {opening}\n      if (closing) data.closing = closing\n      data.properties = properties\n\n      node.data = {position: data}\n    }\n  }\n\n  return result\n}\n\n/**\n * Turn a p5 location into a position.\n *\n * @param {Token.Location} loc\n *   Location.\n * @returns {Position | undefined}\n *   Position or nothing.\n */\nfunction position(loc) {\n  const start = point({\n    line: loc.startLine,\n    column: loc.startCol,\n    offset: loc.startOffset\n  })\n  const end = point({\n    line: loc.endLine,\n    column: loc.endCol,\n    offset: loc.endOffset\n  })\n\n  // @ts-expect-error: we do use `undefined` for points if one or the other\n  // exists.\n  return start || end ? {start, end} : undefined\n}\n\n/**\n * Filter out invalid points.\n *\n * @param {Point} point\n *   Point with potentially `undefined` values.\n * @returns {Point | undefined}\n *   Point or nothing.\n */\nfunction point(point) {\n  return point.line && point.column ? point : undefined\n}\n"],"names":["own","hasOwnProperty","proto","Object","prototype","fromParse5","tree","options","settings","one","file","undefined","location","schema","space","verbose","state","node","result","nodeName","reference","type","value","data","patch","quirksMode","mode","children","all","childNodes","document","String","loc","start","toPoint","end","length","position","namespaceURI","svg","index","properties","attrs","attribute","name","prefix","call","x","s","h","tagName","pos","sourceCodeLocation","startTag","endTag","content","element","nodes","results","push","from","to","createLocation","tail","assign","key","property","opening","closing","point","line","startLine","column","startCol","offset","startOffset","endLine","endCol","endOffset"],"sourceRoot":""}