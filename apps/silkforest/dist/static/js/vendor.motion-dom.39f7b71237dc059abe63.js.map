{"version":3,"file":"static/js/vendor.motion-dom.39f7b71237dc059abe63.js","mappings":"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","sources":["webpack://silkforest-web/../../node_modules/motion-dom/dist/es/gestures/drag/state/is-active.mjs","webpack://silkforest-web/../../node_modules/motion-dom/dist/es/gestures/utils/setup.mjs","webpack://silkforest-web/../../node_modules/motion-dom/dist/es/utils/resolve-elements.mjs","webpack://silkforest-web/../../node_modules/motion-dom/dist/es/gestures/hover.mjs","webpack://silkforest-web/../../node_modules/motion-dom/dist/es/gestures/utils/is-primary-pointer.mjs","webpack://silkforest-web/../../node_modules/motion-dom/dist/es/gestures/press/utils/state.mjs","webpack://silkforest-web/../../node_modules/motion-dom/dist/es/gestures/press/utils/keyboard.mjs","webpack://silkforest-web/../../node_modules/motion-dom/dist/es/gestures/press/utils/is-keyboard-accessible.mjs","webpack://silkforest-web/../../node_modules/motion-dom/dist/es/gestures/utils/is-node-or-child.mjs","webpack://silkforest-web/../../node_modules/motion-dom/dist/es/gestures/press/index.mjs","webpack://silkforest-web/../../node_modules/motion-dom/dist/es/gestures/drag/state/set-active.mjs"],"sourcesContent":["const isDragging = {\n    x: false,\n    y: false,\n};\nfunction isDragActive() {\n    return isDragging.x || isDragging.y;\n}\n\nexport { isDragActive, isDragging };\n","import { resolveElements } from '../../utils/resolve-elements.mjs';\n\nfunction setupGesture(elementOrSelector, options) {\n    const elements = resolveElements(elementOrSelector);\n    const gestureAbortController = new AbortController();\n    const eventOptions = {\n        passive: true,\n        ...options,\n        signal: gestureAbortController.signal,\n    };\n    const cancel = () => gestureAbortController.abort();\n    return [elements, eventOptions, cancel];\n}\n\nexport { setupGesture };\n","function resolveElements(elementOrSelector, scope, selectorCache) {\n    var _a;\n    if (elementOrSelector instanceof Element) {\n        return [elementOrSelector];\n    }\n    else if (typeof elementOrSelector === \"string\") {\n        let root = document;\n        if (scope) {\n            // TODO: Refactor to utils package\n            // invariant(\n            //     Boolean(scope.current),\n            //     \"Scope provided, but no element detected.\"\n            // )\n            root = scope.current;\n        }\n        const elements = (_a = selectorCache === null || selectorCache === void 0 ? void 0 : selectorCache[elementOrSelector]) !== null && _a !== void 0 ? _a : root.querySelectorAll(elementOrSelector);\n        return elements ? Array.from(elements) : [];\n    }\n    return Array.from(elementOrSelector);\n}\n\nexport { resolveElements };\n","import { isDragActive } from './drag/state/is-active.mjs';\nimport { setupGesture } from './utils/setup.mjs';\n\n/**\n * Filter out events that are not pointer events, or are triggering\n * while a Motion gesture is active.\n */\nfunction filterEvents(callback) {\n    return (event) => {\n        if (event.pointerType === \"touch\" || isDragActive())\n            return;\n        callback(event);\n    };\n}\n/**\n * Create a hover gesture. hover() is different to .addEventListener(\"pointerenter\")\n * in that it has an easier syntax, filters out polyfilled touch events, interoperates\n * with drag gestures, and automatically removes the \"pointerennd\" event listener when the hover ends.\n *\n * @public\n */\nfunction hover(elementOrSelector, onHoverStart, options = {}) {\n    const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);\n    const onPointerEnter = filterEvents((enterEvent) => {\n        const { target } = enterEvent;\n        const onHoverEnd = onHoverStart(enterEvent);\n        if (!onHoverEnd || !target)\n            return;\n        const onPointerLeave = filterEvents((leaveEvent) => {\n            onHoverEnd(leaveEvent);\n            target.removeEventListener(\"pointerleave\", onPointerLeave);\n        });\n        target.addEventListener(\"pointerleave\", onPointerLeave, eventOptions);\n    });\n    elements.forEach((element) => {\n        element.addEventListener(\"pointerenter\", onPointerEnter, eventOptions);\n    });\n    return cancel;\n}\n\nexport { hover };\n","const isPrimaryPointer = (event) => {\n    if (event.pointerType === \"mouse\") {\n        return typeof event.button !== \"number\" || event.button <= 0;\n    }\n    else {\n        /**\n         * isPrimary is true for all mice buttons, whereas every touch point\n         * is regarded as its own input. So subsequent concurrent touch points\n         * will be false.\n         *\n         * Specifically match against false here as incomplete versions of\n         * PointerEvents in very old browser might have it set as undefined.\n         */\n        return event.isPrimary !== false;\n    }\n};\n\nexport { isPrimaryPointer };\n","const isPressing = new WeakSet();\n\nexport { isPressing };\n","import { isPressing } from './state.mjs';\n\n/**\n * Filter out events that are not \"Enter\" keys.\n */\nfunction filterEvents(callback) {\n    return (event) => {\n        if (event.key !== \"Enter\")\n            return;\n        callback(event);\n    };\n}\nfunction firePointerEvent(target, type) {\n    target.dispatchEvent(new PointerEvent(\"pointer\" + type, { isPrimary: true, bubbles: true }));\n}\nconst enableKeyboardPress = (focusEvent, eventOptions) => {\n    const element = focusEvent.currentTarget;\n    if (!element)\n        return;\n    const handleKeydown = filterEvents(() => {\n        if (isPressing.has(element))\n            return;\n        firePointerEvent(element, \"down\");\n        const handleKeyup = filterEvents(() => {\n            firePointerEvent(element, \"up\");\n        });\n        const handleBlur = () => firePointerEvent(element, \"cancel\");\n        element.addEventListener(\"keyup\", handleKeyup, eventOptions);\n        element.addEventListener(\"blur\", handleBlur, eventOptions);\n    });\n    element.addEventListener(\"keydown\", handleKeydown, eventOptions);\n    /**\n     * Add an event listener that fires on blur to remove the keydown events.\n     */\n    element.addEventListener(\"blur\", () => element.removeEventListener(\"keydown\", handleKeydown), eventOptions);\n};\n\nexport { enableKeyboardPress };\n","const focusableElements = new Set([\n    \"BUTTON\",\n    \"INPUT\",\n    \"SELECT\",\n    \"TEXTAREA\",\n    \"A\",\n]);\nfunction isElementKeyboardAccessible(element) {\n    return focusableElements.has(element.tagName) || element.tabIndex !== -1;\n}\n\nexport { isElementKeyboardAccessible };\n","/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\nconst isNodeOrChild = (parent, child) => {\n    if (!child) {\n        return false;\n    }\n    else if (parent === child) {\n        return true;\n    }\n    else {\n        return isNodeOrChild(parent, child.parentElement);\n    }\n};\n\nexport { isNodeOrChild };\n","import { isDragActive } from '../drag/state/is-active.mjs';\nimport { isPrimaryPointer } from '../utils/is-primary-pointer.mjs';\nimport { setupGesture } from '../utils/setup.mjs';\nimport { enableKeyboardPress } from './utils/keyboard.mjs';\nimport { isElementKeyboardAccessible } from './utils/is-keyboard-accessible.mjs';\nimport { isNodeOrChild } from '../utils/is-node-or-child.mjs';\nimport { isPressing } from './utils/state.mjs';\n\n/**\n * Filter out events that are not primary pointer events, or are triggering\n * while a Motion gesture is active.\n */\nfunction isValidPressEvent(event) {\n    return isPrimaryPointer(event) && !isDragActive();\n}\n/**\n * Create a press gesture.\n *\n * Press is different to `\"pointerdown\"`, `\"pointerup\"` in that it\n * automatically filters out secondary pointer events like right\n * click and multitouch.\n *\n * It also adds accessibility support for keyboards, where\n * an element with a press gesture will receive focus and\n *  trigger on Enter `\"keydown\"` and `\"keyup\"` events.\n *\n * This is different to a browser's `\"click\"` event, which does\n * respond to keyboards but only for the `\"click\"` itself, rather\n * than the press start and end/cancel. The element also needs\n * to be focusable for this to work, whereas a press gesture will\n * make an element focusable by default.\n *\n * @public\n */\nfunction press(elementOrSelector, onPressStart, options = {}) {\n    const [elements, eventOptions, cancelEvents] = setupGesture(elementOrSelector, options);\n    const startPress = (startEvent) => {\n        const element = startEvent.currentTarget;\n        if (!isValidPressEvent(startEvent) || isPressing.has(element))\n            return;\n        isPressing.add(element);\n        const onPressEnd = onPressStart(startEvent);\n        const onPointerEnd = (endEvent, success) => {\n            window.removeEventListener(\"pointerup\", onPointerUp);\n            window.removeEventListener(\"pointercancel\", onPointerCancel);\n            if (!isValidPressEvent(endEvent) || !isPressing.has(element)) {\n                return;\n            }\n            isPressing.delete(element);\n            if (onPressEnd) {\n                onPressEnd(endEvent, { success });\n            }\n        };\n        const onPointerUp = (upEvent) => {\n            onPointerEnd(upEvent, options.useGlobalTarget ||\n                isNodeOrChild(element, upEvent.target));\n        };\n        const onPointerCancel = (cancelEvent) => {\n            onPointerEnd(cancelEvent, false);\n        };\n        window.addEventListener(\"pointerup\", onPointerUp, eventOptions);\n        window.addEventListener(\"pointercancel\", onPointerCancel, eventOptions);\n    };\n    elements.forEach((element) => {\n        if (!isElementKeyboardAccessible(element)) {\n            element.tabIndex = 0;\n        }\n        const target = options.useGlobalTarget ? window : element;\n        target.addEventListener(\"pointerdown\", startPress, eventOptions);\n        element.addEventListener(\"focus\", (event) => enableKeyboardPress(event, eventOptions), eventOptions);\n    });\n    return cancelEvents;\n}\n\nexport { press };\n","import { isDragging } from './is-active.mjs';\n\nfunction setDragLock(axis) {\n    if (axis === \"x\" || axis === \"y\") {\n        if (isDragging[axis]) {\n            return null;\n        }\n        else {\n            isDragging[axis] = true;\n            return () => {\n                isDragging[axis] = false;\n            };\n        }\n    }\n    else {\n        if (isDragging.x || isDragging.y) {\n            return null;\n        }\n        else {\n            isDragging.x = isDragging.y = true;\n            return () => {\n                isDragging.x = isDragging.y = false;\n            };\n        }\n    }\n}\n\nexport { setDragLock };\n"],"names":["isDragging","x","y","isDragActive","setupGesture","elementOrSelector","options","elements","scope","selectorCache","_a","Element","root","document","current","querySelectorAll","Array","from","resolveElements","gestureAbortController","AbortController","passive","signal","abort","filterEvents","callback","event","pointerType","hover","onHoverStart","eventOptions","cancel","onPointerEnter","enterEvent","target","onHoverEnd","onPointerLeave","leaveEvent","removeEventListener","addEventListener","forEach","element","isPrimaryPointer","button","isPrimary","isPressing","WeakSet","key","firePointerEvent","type","dispatchEvent","PointerEvent","bubbles","enableKeyboardPress","focusEvent","currentTarget","handleKeydown","has","handleKeyup","focusableElements","Set","isNodeOrChild","parent","child","parentElement","isValidPressEvent","press","onPressStart","cancelEvents","startPress","startEvent","add","onPressEnd","onPointerEnd","endEvent","success","window","onPointerUp","onPointerCancel","delete","upEvent","useGlobalTarget","cancelEvent","tagName","tabIndex","isElementKeyboardAccessible","setDragLock","axis"],"sourceRoot":""}