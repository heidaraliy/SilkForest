{"version":3,"file":"static/js/vendor.micromark-extension-gfm-strikethrough.c95ecc14a5d1f99ab57e.js","mappings":"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","sources":["webpack://silkforest-web/../../node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js"],"sourcesContent":["/**\n * @import {Options} from 'micromark-extension-gfm-strikethrough'\n * @import {Event, Extension, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport { splice } from 'micromark-util-chunked';\nimport { classifyCharacter } from 'micromark-util-classify-character';\nimport { resolveAll } from 'micromark-util-resolve-all';\n/**\n * Create an extension for `micromark` to enable GFM strikethrough syntax.\n *\n * @param {Options | null | undefined} [options={}]\n *   Configuration.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable GFM strikethrough syntax.\n */\nexport function gfmStrikethrough(options) {\n  const options_ = options || {};\n  let single = options_.singleTilde;\n  const tokenizer = {\n    name: 'strikethrough',\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  };\n  if (single === null || single === undefined) {\n    single = true;\n  }\n  return {\n    text: {\n      [126]: tokenizer\n    },\n    insideSpan: {\n      null: [tokenizer]\n    },\n    attentionMarkers: {\n      null: [126]\n    }\n  };\n\n  /**\n   * Take events and resolve strikethrough.\n   *\n   * @type {Resolver}\n   */\n  function resolveAllStrikethrough(events, context) {\n    let index = -1;\n\n    // Walk through all events.\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (events[index][0] === 'enter' && events[index][1].type === 'strikethroughSequenceTemporary' && events[index][1]._close) {\n        let open = index;\n\n        // Now walk back to find an opener.\n        while (open--) {\n          // Find a token that can open the closer.\n          if (events[open][0] === 'exit' && events[open][1].type === 'strikethroughSequenceTemporary' && events[open][1]._open &&\n          // If the sizes are the same:\n          events[index][1].end.offset - events[index][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {\n            events[index][1].type = 'strikethroughSequence';\n            events[open][1].type = 'strikethroughSequence';\n\n            /** @type {Token} */\n            const strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            };\n\n            /** @type {Token} */\n            const text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            };\n\n            // Opening.\n            /** @type {Array<Event>} */\n            const nextEvents = [['enter', strikethrough, context], ['enter', events[open][1], context], ['exit', events[open][1], context], ['enter', text, context]];\n            const insideSpan = context.parser.constructs.insideSpan.null;\n            if (insideSpan) {\n              // Between.\n              splice(nextEvents, nextEvents.length, 0, resolveAll(insideSpan, events.slice(open + 1, index), context));\n            }\n\n            // Closing.\n            splice(nextEvents, nextEvents.length, 0, [['exit', text, context], ['enter', events[index][1], context], ['exit', events[index][1], context], ['exit', strikethrough, context]]);\n            splice(events, open - 1, index - open + 3, nextEvents);\n            index = open + nextEvents.length - 2;\n            break;\n          }\n        }\n      }\n    }\n    index = -1;\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = \"data\";\n      }\n    }\n    return events;\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeStrikethrough(effects, ok, nok) {\n    const previous = this.previous;\n    const events = this.events;\n    let size = 0;\n    return start;\n\n    /** @type {State} */\n    function start(code) {\n      if (previous === 126 && events[events.length - 1][1].type !== \"characterEscape\") {\n        return nok(code);\n      }\n      effects.enter('strikethroughSequenceTemporary');\n      return more(code);\n    }\n\n    /** @type {State} */\n    function more(code) {\n      const before = classifyCharacter(previous);\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code);\n        effects.consume(code);\n        size++;\n        return more;\n      }\n      if (size < 2 && !single) return nok(code);\n      const token = effects.exit('strikethroughSequenceTemporary');\n      const after = classifyCharacter(code);\n      token._open = !after || after === 2 && Boolean(before);\n      token._close = !before || before === 2 && Boolean(after);\n      return ok(code);\n    }\n  }\n}"],"names":["gfmStrikethrough","options","single","singleTilde","tokenizer","name","tokenize","effects","ok","nok","previous","this","events","size","code","length","type","enter","more","before","consume","token","exit","after","_open","Boolean","_close","resolveAll","context","index","open","end","offset","start","strikethrough","Object","assign","text","nextEvents","insideSpan","parser","constructs","null","slice","attentionMarkers"],"sourceRoot":""}