{"version":3,"file":"static/js/vendor.micromark-util-subtokenize.4a6b2a4a2eeeee804483.js","mappings":"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","sources":["webpack://silkforest-web/../../node_modules/micromark-util-subtokenize/lib/splice-buffer.js","webpack://silkforest-web/../../node_modules/micromark-util-subtokenize/index.js"],"sourcesContent":["/**\n * Some of the internal operations of micromark do lots of editing\n * operations on very large arrays. This runs into problems with two\n * properties of most circa-2020 JavaScript interpreters:\n *\n *  - Array-length modifications at the high end of an array (push/pop) are\n *    expected to be common and are implemented in (amortized) time\n *    proportional to the number of elements added or removed, whereas\n *    other operations (shift/unshift and splice) are much less efficient.\n *  - Function arguments are passed on the stack, so adding tens of thousands\n *    of elements to an array with `arr.push(...newElements)` will frequently\n *    cause stack overflows. (see <https://stackoverflow.com/questions/22123769/rangeerror-maximum-call-stack-size-exceeded-why>)\n *\n * SpliceBuffers are an implementation of gap buffers, which are a\n * generalization of the \"queue made of two stacks\" idea. The splice buffer\n * maintains a cursor, and moving the cursor has cost proportional to the\n * distance the cursor moves, but inserting, deleting, or splicing in\n * new information at the cursor is as efficient as the push/pop operation.\n * This allows for an efficient sequence of splices (or pushes, pops, shifts,\n * or unshifts) as long such edits happen at the same part of the array or\n * generally sweep through the array from the beginning to the end.\n *\n * The interface for splice buffers also supports large numbers of inputs by\n * passing a single array argument rather passing multiple arguments on the\n * function call stack.\n *\n * @template T\n *   Item type.\n */\nexport class SpliceBuffer {\n  /**\n   * @param {ReadonlyArray<T> | null | undefined} [initial]\n   *   Initial items (optional).\n   * @returns\n   *   Splice buffer.\n   */\n  constructor(initial) {\n    /** @type {Array<T>} */\n    this.left = initial ? [...initial] : [];\n    /** @type {Array<T>} */\n    this.right = [];\n  }\n\n  /**\n   * Array access;\n   * does not move the cursor.\n   *\n   * @param {number} index\n   *   Index.\n   * @return {T}\n   *   Item.\n   */\n  get(index) {\n    if (index < 0 || index >= this.left.length + this.right.length) {\n      throw new RangeError('Cannot access index `' + index + '` in a splice buffer of size `' + (this.left.length + this.right.length) + '`');\n    }\n    if (index < this.left.length) return this.left[index];\n    return this.right[this.right.length - index + this.left.length - 1];\n  }\n\n  /**\n   * The length of the splice buffer, one greater than the largest index in the\n   * array.\n   */\n  get length() {\n    return this.left.length + this.right.length;\n  }\n\n  /**\n   * Remove and return `list[0]`;\n   * moves the cursor to `0`.\n   *\n   * @returns {T | undefined}\n   *   Item, optional.\n   */\n  shift() {\n    this.setCursor(0);\n    return this.right.pop();\n  }\n\n  /**\n   * Slice the buffer to get an array;\n   * does not move the cursor.\n   *\n   * @param {number} start\n   *   Start.\n   * @param {number | null | undefined} [end]\n   *   End (optional).\n   * @returns {Array<T>}\n   *   Array of items.\n   */\n  slice(start, end) {\n    /** @type {number} */\n    const stop = end === null || end === undefined ? Number.POSITIVE_INFINITY : end;\n    if (stop < this.left.length) {\n      return this.left.slice(start, stop);\n    }\n    if (start > this.left.length) {\n      return this.right.slice(this.right.length - stop + this.left.length, this.right.length - start + this.left.length).reverse();\n    }\n    return this.left.slice(start).concat(this.right.slice(this.right.length - stop + this.left.length).reverse());\n  }\n\n  /**\n   * Mimics the behavior of Array.prototype.splice() except for the change of\n   * interface necessary to avoid segfaults when patching in very large arrays.\n   *\n   * This operation moves cursor is moved to `start` and results in the cursor\n   * placed after any inserted items.\n   *\n   * @param {number} start\n   *   Start;\n   *   zero-based index at which to start changing the array;\n   *   negative numbers count backwards from the end of the array and values\n   *   that are out-of bounds are clamped to the appropriate end of the array.\n   * @param {number | null | undefined} [deleteCount=0]\n   *   Delete count (default: `0`);\n   *   maximum number of elements to delete, starting from start.\n   * @param {Array<T> | null | undefined} [items=[]]\n   *   Items to include in place of the deleted items (default: `[]`).\n   * @return {Array<T>}\n   *   Any removed items.\n   */\n  splice(start, deleteCount, items) {\n    /** @type {number} */\n    const count = deleteCount || 0;\n    this.setCursor(Math.trunc(start));\n    const removed = this.right.splice(this.right.length - count, Number.POSITIVE_INFINITY);\n    if (items) chunkedPush(this.left, items);\n    return removed.reverse();\n  }\n\n  /**\n   * Remove and return the highest-numbered item in the array, so\n   * `list[list.length - 1]`;\n   * Moves the cursor to `length`.\n   *\n   * @returns {T | undefined}\n   *   Item, optional.\n   */\n  pop() {\n    this.setCursor(Number.POSITIVE_INFINITY);\n    return this.left.pop();\n  }\n\n  /**\n   * Inserts a single item to the high-numbered side of the array;\n   * moves the cursor to `length`.\n   *\n   * @param {T} item\n   *   Item.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  push(item) {\n    this.setCursor(Number.POSITIVE_INFINITY);\n    this.left.push(item);\n  }\n\n  /**\n   * Inserts many items to the high-numbered side of the array.\n   * Moves the cursor to `length`.\n   *\n   * @param {Array<T>} items\n   *   Items.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  pushMany(items) {\n    this.setCursor(Number.POSITIVE_INFINITY);\n    chunkedPush(this.left, items);\n  }\n\n  /**\n   * Inserts a single item to the low-numbered side of the array;\n   * Moves the cursor to `0`.\n   *\n   * @param {T} item\n   *   Item.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  unshift(item) {\n    this.setCursor(0);\n    this.right.push(item);\n  }\n\n  /**\n   * Inserts many items to the low-numbered side of the array;\n   * moves the cursor to `0`.\n   *\n   * @param {Array<T>} items\n   *   Items.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  unshiftMany(items) {\n    this.setCursor(0);\n    chunkedPush(this.right, items.reverse());\n  }\n\n  /**\n   * Move the cursor to a specific position in the array. Requires\n   * time proportional to the distance moved.\n   *\n   * If `n < 0`, the cursor will end up at the beginning.\n   * If `n > length`, the cursor will end up at the end.\n   *\n   * @param {number} n\n   *   Position.\n   * @return {undefined}\n   *   Nothing.\n   */\n  setCursor(n) {\n    if (n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0) return;\n    if (n < this.left.length) {\n      // Move cursor to the this.left\n      const removed = this.left.splice(n, Number.POSITIVE_INFINITY);\n      chunkedPush(this.right, removed.reverse());\n    } else {\n      // Move cursor to the this.right\n      const removed = this.right.splice(this.left.length + this.right.length - n, Number.POSITIVE_INFINITY);\n      chunkedPush(this.left, removed.reverse());\n    }\n  }\n}\n\n/**\n * Avoid stack overflow by pushing items onto the stack in segments\n *\n * @template T\n *   Item type.\n * @param {Array<T>} list\n *   List to inject into.\n * @param {ReadonlyArray<T>} right\n *   Items to inject.\n * @return {undefined}\n *   Nothing.\n */\nfunction chunkedPush(list, right) {\n  /** @type {number} */\n  let chunkStart = 0;\n  if (right.length < 10000) {\n    list.push(...right);\n  } else {\n    while (chunkStart < right.length) {\n      list.push(...right.slice(chunkStart, chunkStart + 10000));\n      chunkStart += 10000;\n    }\n  }\n}","/**\n * @import {Chunk, Event, Token} from 'micromark-util-types'\n */\n\nimport { splice } from 'micromark-util-chunked';\nimport { SpliceBuffer } from './lib/splice-buffer.js';\n\n// Hidden API exposed for testing.\nexport { SpliceBuffer } from './lib/splice-buffer.js';\n\n/**\n * Tokenize subcontent.\n *\n * @param {Array<Event>} eventsArray\n *   List of events.\n * @returns {boolean}\n *   Whether subtokens were found.\n */\n// eslint-disable-next-line complexity\nexport function subtokenize(eventsArray) {\n  /** @type {Record<string, number>} */\n  const jumps = {};\n  let index = -1;\n  /** @type {Event} */\n  let event;\n  /** @type {number | undefined} */\n  let lineIndex;\n  /** @type {number} */\n  let otherIndex;\n  /** @type {Event} */\n  let otherEvent;\n  /** @type {Array<Event>} */\n  let parameters;\n  /** @type {Array<Event>} */\n  let subevents;\n  /** @type {boolean | undefined} */\n  let more;\n  const events = new SpliceBuffer(eventsArray);\n  while (++index < events.length) {\n    while (index in jumps) {\n      index = jumps[index];\n    }\n    event = events.get(index);\n\n    // Add a hook for the GFM tasklist extension, which needs to know if text\n    // is in the first content of a list item.\n    if (index && event[1].type === \"chunkFlow\" && events.get(index - 1)[1].type === \"listItemPrefix\") {\n      subevents = event[1]._tokenizer.events;\n      otherIndex = 0;\n      if (otherIndex < subevents.length && subevents[otherIndex][1].type === \"lineEndingBlank\") {\n        otherIndex += 2;\n      }\n      if (otherIndex < subevents.length && subevents[otherIndex][1].type === \"content\") {\n        while (++otherIndex < subevents.length) {\n          if (subevents[otherIndex][1].type === \"content\") {\n            break;\n          }\n          if (subevents[otherIndex][1].type === \"chunkText\") {\n            subevents[otherIndex][1]._isInFirstContentOfListItem = true;\n            otherIndex++;\n          }\n        }\n      }\n    }\n\n    // Enter.\n    if (event[0] === 'enter') {\n      if (event[1].contentType) {\n        Object.assign(jumps, subcontent(events, index));\n        index = jumps[index];\n        more = true;\n      }\n    }\n    // Exit.\n    else if (event[1]._container) {\n      otherIndex = index;\n      lineIndex = undefined;\n      while (otherIndex--) {\n        otherEvent = events.get(otherIndex);\n        if (otherEvent[1].type === \"lineEnding\" || otherEvent[1].type === \"lineEndingBlank\") {\n          if (otherEvent[0] === 'enter') {\n            if (lineIndex) {\n              events.get(lineIndex)[1].type = \"lineEndingBlank\";\n            }\n            otherEvent[1].type = \"lineEnding\";\n            lineIndex = otherIndex;\n          }\n        } else {\n          break;\n        }\n      }\n      if (lineIndex) {\n        // Fix position.\n        event[1].end = {\n          ...events.get(lineIndex)[1].start\n        };\n\n        // Switch container exit w/ line endings.\n        parameters = events.slice(lineIndex, index);\n        parameters.unshift(event);\n        events.splice(lineIndex, index - lineIndex + 1, parameters);\n      }\n    }\n  }\n\n  // The changes to the `events` buffer must be copied back into the eventsArray\n  splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));\n  return !more;\n}\n\n/**\n * Tokenize embedded tokens.\n *\n * @param {SpliceBuffer<Event>} events\n *   Events.\n * @param {number} eventIndex\n *   Index.\n * @returns {Record<string, number>}\n *   Gaps.\n */\nfunction subcontent(events, eventIndex) {\n  const token = events.get(eventIndex)[1];\n  const context = events.get(eventIndex)[2];\n  let startPosition = eventIndex - 1;\n  /** @type {Array<number>} */\n  const startPositions = [];\n  const tokenizer = token._tokenizer || context.parser[token.contentType](token.start);\n  const childEvents = tokenizer.events;\n  /** @type {Array<[number, number]>} */\n  const jumps = [];\n  /** @type {Record<string, number>} */\n  const gaps = {};\n  /** @type {Array<Chunk>} */\n  let stream;\n  /** @type {Token | undefined} */\n  let previous;\n  let index = -1;\n  /** @type {Token | undefined} */\n  let current = token;\n  let adjust = 0;\n  let start = 0;\n  const breaks = [start];\n\n  // Loop forward through the linked tokens to pass them in order to the\n  // subtokenizer.\n  while (current) {\n    // Find the position of the event for this token.\n    while (events.get(++startPosition)[1] !== current) {\n      // Empty.\n    }\n    startPositions.push(startPosition);\n    if (!current._tokenizer) {\n      stream = context.sliceStream(current);\n      if (!current.next) {\n        stream.push(null);\n      }\n      if (previous) {\n        tokenizer.defineSkip(current.start);\n      }\n      if (current._isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = true;\n      }\n      tokenizer.write(stream);\n      if (current._isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = undefined;\n      }\n    }\n\n    // Unravel the next token.\n    previous = current;\n    current = current.next;\n  }\n\n  // Now, loop back through all events (and linked tokens), to figure out which\n  // parts belong where.\n  current = token;\n  while (++index < childEvents.length) {\n    if (\n    // Find a void token that includes a break.\n    childEvents[index][0] === 'exit' && childEvents[index - 1][0] === 'enter' && childEvents[index][1].type === childEvents[index - 1][1].type && childEvents[index][1].start.line !== childEvents[index][1].end.line) {\n      start = index + 1;\n      breaks.push(start);\n      // Help GC.\n      current._tokenizer = undefined;\n      current.previous = undefined;\n      current = current.next;\n    }\n  }\n\n  // Help GC.\n  tokenizer.events = [];\n\n  // If there’s one more token (which is the cases for lines that end in an\n  // EOF), that’s perfect: the last point we found starts it.\n  // If there isn’t then make sure any remaining content is added to it.\n  if (current) {\n    // Help GC.\n    current._tokenizer = undefined;\n    current.previous = undefined;\n  } else {\n    breaks.pop();\n  }\n\n  // Now splice the events from the subtokenizer into the current events,\n  // moving back to front so that splice indices aren’t affected.\n  index = breaks.length;\n  while (index--) {\n    const slice = childEvents.slice(breaks[index], breaks[index + 1]);\n    const start = startPositions.pop();\n    jumps.push([start, start + slice.length - 1]);\n    events.splice(start, 2, slice);\n  }\n  jumps.reverse();\n  index = -1;\n  while (++index < jumps.length) {\n    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1];\n    adjust += jumps[index][1] - jumps[index][0] - 1;\n  }\n  return gaps;\n}"],"names":["SpliceBuffer","constructor","initial","this","left","right","get","index","length","RangeError","shift","setCursor","pop","slice","start","end","stop","Number","POSITIVE_INFINITY","reverse","concat","splice","deleteCount","items","count","Math","trunc","removed","chunkedPush","push","item","pushMany","unshift","unshiftMany","n","list","chunkStart","subtokenize","eventsArray","jumps","event","lineIndex","otherIndex","otherEvent","parameters","subevents","more","events","type","_tokenizer","_isInFirstContentOfListItem","contentType","Object","assign","subcontent","_container","undefined","eventIndex","token","context","startPosition","startPositions","tokenizer","parser","childEvents","gaps","stream","previous","current","adjust","breaks","sliceStream","next","defineSkip","_gfmTasklistFirstContentOfListItem","write","line"],"sourceRoot":""}