{"version":3,"file":"static/js/vendor.d3-array.557690b1489a5fff7ab2.js","mappings":"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","sources":["webpack://silkforest-web/../../node_modules/d3-array/src/ascending.js","webpack://silkforest-web/../../node_modules/d3-array/src/bisect.js","webpack://silkforest-web/../../node_modules/d3-array/src/descending.js","webpack://silkforest-web/../../node_modules/d3-array/src/bisector.js","webpack://silkforest-web/../../node_modules/d3-array/src/number.js","webpack://silkforest-web/../../node_modules/d3-array/src/max.js","webpack://silkforest-web/../../node_modules/d3-array/src/min.js","webpack://silkforest-web/../../node_modules/d3-array/src/sort.js","webpack://silkforest-web/../../node_modules/d3-array/src/quickselect.js","webpack://silkforest-web/../../node_modules/d3-array/src/quantile.js","webpack://silkforest-web/../../node_modules/d3-array/src/range.js","webpack://silkforest-web/../../node_modules/d3-array/src/ticks.js"],"sourcesContent":["export default function ascending(a, b) {\n  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n","import ascending from \"./ascending.js\";\nimport bisector from \"./bisector.js\";\nimport number from \"./number.js\";\n\nconst ascendingBisect = bisector(ascending);\nexport const bisectRight = ascendingBisect.right;\nexport const bisectLeft = ascendingBisect.left;\nexport const bisectCenter = bisector(number).center;\nexport default bisectRight;\n","export default function descending(a, b) {\n  return a == null || b == null ? NaN\n    : b < a ? -1\n    : b > a ? 1\n    : b >= a ? 0\n    : NaN;\n}\n","import ascending from \"./ascending.js\";\nimport descending from \"./descending.js\";\n\nexport default function bisector(f) {\n  let compare1, compare2, delta;\n\n  // If an accessor is specified, promote it to a comparator. In this case we\n  // can test whether the search value is (self-) comparable. We can’t do this\n  // for a comparator (except for specific, known comparators) because we can’t\n  // tell if the comparator is symmetric, and an asymmetric comparator can’t be\n  // used to test whether a single value is comparable.\n  if (f.length !== 2) {\n    compare1 = ascending;\n    compare2 = (d, x) => ascending(f(d), x);\n    delta = (d, x) => f(d) - x;\n  } else {\n    compare1 = f === ascending || f === descending ? f : zero;\n    compare2 = f;\n    delta = f;\n  }\n\n  function left(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function right(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) <= 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function center(a, x, lo = 0, hi = a.length) {\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {left, center, right};\n}\n\nfunction zero() {\n  return 0;\n}\n","export default function number(x) {\n  return x === null ? NaN : +x;\n}\n\nexport function* numbers(values, valueof) {\n  if (valueof === undefined) {\n    for (let value of values) {\n      if (value != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  }\n}\n","export default function max(values, valueof) {\n  let max;\n  if (valueof === undefined) {\n    for (const value of values) {\n      if (value != null\n          && (max < value || (max === undefined && value >= value))) {\n        max = value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null\n          && (max < value || (max === undefined && value >= value))) {\n        max = value;\n      }\n    }\n  }\n  return max;\n}\n","export default function min(values, valueof) {\n  let min;\n  if (valueof === undefined) {\n    for (const value of values) {\n      if (value != null\n          && (min > value || (min === undefined && value >= value))) {\n        min = value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null\n          && (min > value || (min === undefined && value >= value))) {\n        min = value;\n      }\n    }\n  }\n  return min;\n}\n","import ascending from \"./ascending.js\";\nimport permute from \"./permute.js\";\n\nexport default function sort(values, ...F) {\n  if (typeof values[Symbol.iterator] !== \"function\") throw new TypeError(\"values is not iterable\");\n  values = Array.from(values);\n  let [f] = F;\n  if ((f && f.length !== 2) || F.length > 1) {\n    const index = Uint32Array.from(values, (d, i) => i);\n    if (F.length > 1) {\n      F = F.map(f => values.map(f));\n      index.sort((i, j) => {\n        for (const f of F) {\n          const c = ascendingDefined(f[i], f[j]);\n          if (c) return c;\n        }\n      });\n    } else {\n      f = values.map(f);\n      index.sort((i, j) => ascendingDefined(f[i], f[j]));\n    }\n    return permute(values, index);\n  }\n  return values.sort(compareDefined(f));\n}\n\nexport function compareDefined(compare = ascending) {\n  if (compare === ascending) return ascendingDefined;\n  if (typeof compare !== \"function\") throw new TypeError(\"compare is not a function\");\n  return (a, b) => {\n    const x = compare(a, b);\n    if (x || x === 0) return x;\n    return (compare(b, b) === 0) - (compare(a, a) === 0);\n  };\n}\n\nexport function ascendingDefined(a, b) {\n  return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);\n}\n","import {ascendingDefined, compareDefined} from \"./sort.js\";\n\n// Based on https://github.com/mourner/quickselect\n// ISC license, Copyright 2018 Vladimir Agafonkin.\nexport default function quickselect(array, k, left = 0, right = Infinity, compare) {\n  k = Math.floor(k);\n  left = Math.floor(Math.max(0, left));\n  right = Math.floor(Math.min(array.length - 1, right));\n\n  if (!(left <= k && k <= right)) return array;\n\n  compare = compare === undefined ? ascendingDefined : compareDefined(compare);\n\n  while (right > left) {\n    if (right - left > 600) {\n      const n = right - left + 1;\n      const m = k - left + 1;\n      const z = Math.log(n);\n      const s = 0.5 * Math.exp(2 * z / 3);\n      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n      quickselect(array, k, newLeft, newRight, compare);\n    }\n\n    const t = array[k];\n    let i = left;\n    let j = right;\n\n    swap(array, left, k);\n    if (compare(array[right], t) > 0) swap(array, left, right);\n\n    while (i < j) {\n      swap(array, i, j), ++i, --j;\n      while (compare(array[i], t) < 0) ++i;\n      while (compare(array[j], t) > 0) --j;\n    }\n\n    if (compare(array[left], t) === 0) swap(array, left, j);\n    else ++j, swap(array, j, right);\n\n    if (j <= k) left = j + 1;\n    if (k <= j) right = j - 1;\n  }\n\n  return array;\n}\n\nfunction swap(array, i, j) {\n  const t = array[i];\n  array[i] = array[j];\n  array[j] = t;\n}\n","import max from \"./max.js\";\nimport maxIndex from \"./maxIndex.js\";\nimport min from \"./min.js\";\nimport minIndex from \"./minIndex.js\";\nimport quickselect from \"./quickselect.js\";\nimport number, {numbers} from \"./number.js\";\nimport {ascendingDefined} from \"./sort.js\";\nimport greatest from \"./greatest.js\";\n\nexport default function quantile(values, p, valueof) {\n  values = Float64Array.from(numbers(values, valueof));\n  if (!(n = values.length) || isNaN(p = +p)) return;\n  if (p <= 0 || n < 2) return min(values);\n  if (p >= 1) return max(values);\n  var n,\n      i = (n - 1) * p,\n      i0 = Math.floor(i),\n      value0 = max(quickselect(values, i0).subarray(0, i0 + 1)),\n      value1 = min(values.subarray(i0 + 1));\n  return value0 + (value1 - value0) * (i - i0);\n}\n\nexport function quantileSorted(values, p, valueof = number) {\n  if (!(n = values.length) || isNaN(p = +p)) return;\n  if (p <= 0 || n < 2) return +valueof(values[0], 0, values);\n  if (p >= 1) return +valueof(values[n - 1], n - 1, values);\n  var n,\n      i = (n - 1) * p,\n      i0 = Math.floor(i),\n      value0 = +valueof(values[i0], i0, values),\n      value1 = +valueof(values[i0 + 1], i0 + 1, values);\n  return value0 + (value1 - value0) * (i - i0);\n}\n\nexport function quantileIndex(values, p, valueof = number) {\n  if (isNaN(p = +p)) return;\n  numbers = Float64Array.from(values, (_, i) => number(valueof(values[i], i, values)));\n  if (p <= 0) return minIndex(numbers);\n  if (p >= 1) return maxIndex(numbers);\n  var numbers,\n      index = Uint32Array.from(values, (_, i) => i),\n      j = numbers.length - 1,\n      i = Math.floor(j * p);\n  quickselect(index, i, 0, j, (i, j) => ascendingDefined(numbers[i], numbers[j]));\n  i = greatest(index.subarray(0, i + 1), (i) => numbers[i]);\n  return i >= 0 ? i : -1;\n}\n","export default function range(start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n\n  var i = -1,\n      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n      range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n}\n","const e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n\nfunction tickSpec(start, stop, count) {\n  const step = (stop - start) / Math.max(0, count),\n      power = Math.floor(Math.log10(step)),\n      error = step / Math.pow(10, power),\n      factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;\n  let i1, i2, inc;\n  if (power < 0) {\n    inc = Math.pow(10, -power) / factor;\n    i1 = Math.round(start * inc);\n    i2 = Math.round(stop * inc);\n    if (i1 / inc < start) ++i1;\n    if (i2 / inc > stop) --i2;\n    inc = -inc;\n  } else {\n    inc = Math.pow(10, power) * factor;\n    i1 = Math.round(start / inc);\n    i2 = Math.round(stop / inc);\n    if (i1 * inc < start) ++i1;\n    if (i2 * inc > stop) --i2;\n  }\n  if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start, stop, count * 2);\n  return [i1, i2, inc];\n}\n\nexport default function ticks(start, stop, count) {\n  stop = +stop, start = +start, count = +count;\n  if (!(count > 0)) return [];\n  if (start === stop) return [start];\n  const reverse = stop < start, [i1, i2, inc] = reverse ? tickSpec(stop, start, count) : tickSpec(start, stop, count);\n  if (!(i2 >= i1)) return [];\n  const n = i2 - i1 + 1, ticks = new Array(n);\n  if (reverse) {\n    if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) / -inc;\n    else for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) * inc;\n  } else {\n    if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) / -inc;\n    else for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) * inc;\n  }\n  return ticks;\n}\n\nexport function tickIncrement(start, stop, count) {\n  stop = +stop, start = +start, count = +count;\n  return tickSpec(start, stop, count)[2];\n}\n\nexport function tickStep(start, stop, count) {\n  stop = +stop, start = +start, count = +count;\n  const reverse = stop < start, inc = reverse ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);\n  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);\n}\n"],"names":["ascending","a","b","NaN","ascendingBisect","bisectRight","right","left","center","descending","bisector","f","compare1","compare2","delta","x","lo","hi","length","mid","d","zero","i","number","numbers","values","valueof","undefined","value","index","max","min","compareDefined","compare","TypeError","array","k","Infinity","Math","floor","n","m","z","log","s","exp","sd","sqrt","t","j","swap","quantile","p","Float64Array","from","isNaN","i0","value0","subarray","quantileSorted","range","start","stop","step","arguments","ceil","Array","e10","e5","e2","tickSpec","count","power","log10","error","pow","factor","i1","i2","inc","round","ticks","reverse","tickIncrement","tickStep"],"sourceRoot":""}