{"version":3,"file":"static/js/vendor.hast-util-raw.62260e137f6b1259152a.js","mappings":"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","sources":["webpack://silkforest-web/../../node_modules/hast-util-raw/lib/index.js"],"sourcesContent":["/**\n * @import {Options} from 'hast-util-raw'\n * @import {Comment, Doctype, Element, Nodes, RootContent, Root, Text} from 'hast'\n * @import {Raw} from 'mdast-util-to-hast'\n * @import {DefaultTreeAdapterMap, ParserOptions} from 'parse5'\n * @import {Point} from 'unist'\n */\n\n/**\n * @typedef State\n *   Info passed around about the current state.\n * @property {(node: Nodes) => undefined} handle\n *   Add a hast node to the parser.\n * @property {Options} options\n *   User configuration.\n * @property {Parser<DefaultTreeAdapterMap>} parser\n *   Current parser.\n * @property {boolean} stitches\n *   Whether there are stitches.\n */\n\n/**\n * @typedef Stitch\n *   Custom comment-like value we pass through parse5, which contains a\n *   replacement node that we’ll swap back in afterwards.\n * @property {'comment'} type\n *   Node type.\n * @property {{stitch: Nodes}} value\n *   Replacement value.\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {fromParse5} from 'hast-util-from-parse5'\nimport {toParse5} from 'hast-util-to-parse5'\nimport {htmlVoidElements} from 'html-void-elements'\nimport {Parser, Token, TokenizerMode, html} from 'parse5'\nimport {pointEnd, pointStart} from 'unist-util-position'\nimport {visit} from 'unist-util-visit'\nimport {webNamespaces} from 'web-namespaces'\nimport {zwitch} from 'zwitch'\n\nconst gfmTagfilterExpression =\n  /<(\\/?)(iframe|noembed|noframes|plaintext|script|style|textarea|title|xmp)(?=[\\t\\n\\f\\r />])/gi\n\n// Node types associated with MDX.\n// <https://github.com/mdx-js/mdx/blob/8a56312/packages/mdx/lib/node-types.js>\nconst knownMdxNames = new Set([\n  'mdxFlowExpression',\n  'mdxJsxFlowElement',\n  'mdxJsxTextElement',\n  'mdxTextExpression',\n  'mdxjsEsm'\n])\n\n/** @type {ParserOptions<DefaultTreeAdapterMap>} */\nconst parseOptions = {sourceCodeLocationInfo: true, scriptingEnabled: false}\n\n/**\n * Pass a hast tree through an HTML parser, which will fix nesting, and turn\n * raw nodes into actual nodes.\n *\n * @param {Nodes} tree\n *   Original hast tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Nodes}\n *   Parsed again tree.\n */\nexport function raw(tree, options) {\n  const document = documentMode(tree)\n  /** @type {(node: Nodes, state: State) => undefined} */\n  const one = zwitch('type', {\n    handlers: {root, element, text, comment, doctype, raw: handleRaw},\n    unknown\n  })\n\n  /** @type {State} */\n  const state = {\n    parser: document\n      ? new Parser(parseOptions)\n      : Parser.getFragmentParser(undefined, parseOptions),\n    handle(node) {\n      one(node, state)\n    },\n    stitches: false,\n    options: options || {}\n  }\n\n  one(tree, state)\n  resetTokenizer(state, pointStart())\n\n  const p5 = document ? state.parser.document : state.parser.getFragment()\n  const result = fromParse5(p5, {\n    // To do: support `space`?\n    file: state.options.file\n  })\n\n  if (state.stitches) {\n    visit(result, 'comment', function (node, index, parent) {\n      const stitch = /** @type {Stitch} */ (/** @type {unknown} */ (node))\n      if (stitch.value.stitch && parent && index !== undefined) {\n        /** @type {Array<RootContent>} */\n        const siblings = parent.children\n        // @ts-expect-error: assume the stitch is allowed.\n        siblings[index] = stitch.value.stitch\n        return index\n      }\n    })\n  }\n\n  // Unpack if possible and when not given a `root`.\n  if (\n    result.type === 'root' &&\n    result.children.length === 1 &&\n    result.children[0].type === tree.type\n  ) {\n    return result.children[0]\n  }\n\n  return result\n}\n\n/**\n * Transform all nodes\n *\n * @param {Array<RootContent>} nodes\n *   hast content.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */\nfunction all(nodes, state) {\n  let index = -1\n\n  /* istanbul ignore else - invalid nodes, see rehypejs/rehype-raw#7. */\n  if (nodes) {\n    while (++index < nodes.length) {\n      state.handle(nodes[index])\n    }\n  }\n}\n\n/**\n * Transform a root.\n *\n * @param {Root} node\n *   hast root node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */\nfunction root(node, state) {\n  all(node.children, state)\n}\n\n/**\n * Transform an element.\n *\n * @param {Element} node\n *   hast element node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */\nfunction element(node, state) {\n  startTag(node, state)\n\n  all(node.children, state)\n\n  endTag(node, state)\n}\n\n/**\n * Transform a text.\n *\n * @param {Text} node\n *   hast text node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */\nfunction text(node, state) {\n  // Allow `DATA` through `PLAINTEXT`,\n  // but when hanging in a tag for example,\n  // switch back to `DATA`.\n  // Note: `State` is not exposed by `parse5`, so these numbers are fragile.\n  // See: <https://github.com/inikulin/parse5/blob/46cba43/packages/parse5/lib/tokenizer/index.ts#L58>\n  if (state.parser.tokenizer.state > 4) {\n    state.parser.tokenizer.state = 0\n  }\n\n  /** @type {Token.CharacterToken} */\n  const token = {\n    type: Token.TokenType.CHARACTER,\n    chars: node.value,\n    location: createParse5Location(node)\n  }\n\n  resetTokenizer(state, pointStart(node))\n  // @ts-expect-error: private.\n  state.parser.currentToken = token\n  // @ts-expect-error: private.\n  state.parser._processToken(state.parser.currentToken)\n}\n\n/**\n * Transform a doctype.\n *\n * @param {Doctype} node\n *   hast doctype node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */\nfunction doctype(node, state) {\n  /** @type {Token.DoctypeToken} */\n  const token = {\n    type: Token.TokenType.DOCTYPE,\n    name: 'html',\n    forceQuirks: false,\n    publicId: '',\n    systemId: '',\n    location: createParse5Location(node)\n  }\n\n  resetTokenizer(state, pointStart(node))\n  // @ts-expect-error: private.\n  state.parser.currentToken = token\n  // @ts-expect-error: private.\n  state.parser._processToken(state.parser.currentToken)\n}\n\n/**\n * Transform a stitch.\n *\n * @param {Nodes} node\n *   unknown node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */\nfunction stitch(node, state) {\n  // Mark that there are stitches, so we need to walk the tree and revert them.\n  state.stitches = true\n\n  /** @type {Nodes} */\n  const clone = cloneWithoutChildren(node)\n\n  // Recurse, because to somewhat handle `[<x>]</x>` (where `[]` denotes the\n  // passed through node).\n  if ('children' in node && 'children' in clone) {\n    // Root in root out.\n    const fakeRoot = /** @type {Root} */ (\n      raw({type: 'root', children: node.children}, state.options)\n    )\n    clone.children = fakeRoot.children\n  }\n\n  // Hack: `value` is supposed to be a string, but as none of the tools\n  // (`parse5` or `hast-util-from-parse5`) looks at it, we can pass nodes\n  // through.\n  comment({type: 'comment', value: {stitch: clone}}, state)\n}\n\n/**\n * Transform a comment (or stitch).\n *\n * @param {Comment | Stitch} node\n *   hast comment node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */\nfunction comment(node, state) {\n  /** @type {string} */\n  // @ts-expect-error: we pass stitches through.\n  const data = node.value\n\n  /** @type {Token.CommentToken} */\n  const token = {\n    type: Token.TokenType.COMMENT,\n    data,\n    location: createParse5Location(node)\n  }\n  resetTokenizer(state, pointStart(node))\n  // @ts-expect-error: private.\n  state.parser.currentToken = token\n  // @ts-expect-error: private.\n  state.parser._processToken(state.parser.currentToken)\n}\n\n/**\n * Transform a raw node.\n *\n * @param {Raw} node\n *   hast raw node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */\nfunction handleRaw(node, state) {\n  // Reset preprocessor:\n  // See: <https://github.com/inikulin/parse5/blob/6f7ca60/packages/parse5/lib/tokenizer/preprocessor.ts#L18-L31>.\n  state.parser.tokenizer.preprocessor.html = ''\n  state.parser.tokenizer.preprocessor.pos = -1\n  // @ts-expect-error: private.\n  // type-coverage:ignore-next-line\n  state.parser.tokenizer.preprocessor.lastGapPos = -2\n  // @ts-expect-error: private.\n  // type-coverage:ignore-next-line\n  state.parser.tokenizer.preprocessor.gapStack = []\n  // @ts-expect-error: private.\n  // type-coverage:ignore-next-line\n  state.parser.tokenizer.preprocessor.skipNextNewLine = false\n  state.parser.tokenizer.preprocessor.lastChunkWritten = false\n  state.parser.tokenizer.preprocessor.endOfChunkHit = false\n  // @ts-expect-error: private.\n  // type-coverage:ignore-next-line\n  state.parser.tokenizer.preprocessor.isEol = false\n\n  // Now pass `node.value`.\n  setPoint(state, pointStart(node))\n\n  state.parser.tokenizer.write(\n    state.options.tagfilter\n      ? node.value.replace(gfmTagfilterExpression, '&lt;$1$2')\n      : node.value,\n    false\n  )\n  // @ts-expect-error: private.\n  state.parser.tokenizer._runParsingLoop()\n\n  // Character references hang, so if we ended there, we need to flush\n  // those too.\n  // We reset the preprocessor as if the document ends here.\n  // Then one single call to the relevant state does the trick, parse5\n  // consumes the whole token.\n\n  // Note: `State` is not exposed by `parse5`, so these numbers are fragile.\n  // See: <https://github.com/inikulin/parse5/blob/46cba43/packages/parse5/lib/tokenizer/index.ts#L58>\n  // Note: a change to `parse5`, which breaks this, was merged but not released.\n  // Investigate when it is.\n  // To do: remove next major.\n  /* c8 ignore next 12 -- removed in <https://github.com/inikulin/parse5/pull/897> */\n  if (\n    state.parser.tokenizer.state === 72 /* NAMED_CHARACTER_REFERENCE */ ||\n    // @ts-expect-error: removed.\n    state.parser.tokenizer.state === 78 /* NUMERIC_CHARACTER_REFERENCE_END */\n  ) {\n    state.parser.tokenizer.preprocessor.lastChunkWritten = true\n    /** @type {number} */\n    // @ts-expect-error: private.\n    const cp = state.parser.tokenizer._consume()\n    // @ts-expect-error: private.\n    state.parser.tokenizer._callState(cp)\n  }\n}\n\n/**\n * Crash on an unknown node.\n *\n * @param {unknown} node_\n *   unknown node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Never.\n */\nfunction unknown(node_, state) {\n  const node = /** @type {Nodes} */ (node_)\n\n  if (\n    state.options.passThrough &&\n    state.options.passThrough.includes(node.type)\n  ) {\n    stitch(node, state)\n  } else {\n    let extra = ''\n\n    if (knownMdxNames.has(node.type)) {\n      extra =\n        \". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax\"\n    }\n\n    throw new Error('Cannot compile `' + node.type + '` node' + extra)\n  }\n}\n\n/**\n * Reset the tokenizer of a parser.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Point | undefined} point\n *   Point.\n * @returns {undefined}\n *   Nothing.\n */\nfunction resetTokenizer(state, point) {\n  setPoint(state, point)\n\n  // Process final characters if they’re still there after hibernating.\n  /** @type {Token.CharacterToken} */\n  // @ts-expect-error: private.\n  const token = state.parser.tokenizer.currentCharacterToken\n\n  if (token && token.location) {\n    token.location.endLine = state.parser.tokenizer.preprocessor.line\n    token.location.endCol = state.parser.tokenizer.preprocessor.col + 1\n    token.location.endOffset = state.parser.tokenizer.preprocessor.offset + 1\n    // @ts-expect-error: private.\n    state.parser.currentToken = token\n    // @ts-expect-error: private.\n    state.parser._processToken(state.parser.currentToken)\n  }\n\n  // Reset tokenizer:\n  // See: <https://github.com/inikulin/parse5/blob/6f7ca60/packages/parse5/lib/tokenizer/index.ts#L187-L223>.\n  // Especially putting it back in the `data` state is useful: some elements,\n  // like textareas and iframes, change the state.\n  // See GH-7.\n  // But also if broken HTML is in `raw`, and then a correct element is given.\n  // See GH-11.\n  // @ts-expect-error: private.\n  state.parser.tokenizer.paused = false\n  // @ts-expect-error: private.\n  state.parser.tokenizer.inLoop = false\n\n  // Note: don’t reset `state`, `inForeignNode`, or `lastStartTagName`, we\n  // manually update those when needed.\n  state.parser.tokenizer.active = false\n  // @ts-expect-error: private.\n  state.parser.tokenizer.returnState = TokenizerMode.DATA\n  // @ts-expect-error: private.\n  state.parser.tokenizer.charRefCode = -1\n  // @ts-expect-error: private.\n  state.parser.tokenizer.consumedAfterSnapshot = -1\n  // @ts-expect-error: private.\n  state.parser.tokenizer.currentLocation = null\n  // @ts-expect-error: private.\n  state.parser.tokenizer.currentCharacterToken = null\n  // @ts-expect-error: private.\n  state.parser.tokenizer.currentToken = null\n  // @ts-expect-error: private.\n  state.parser.tokenizer.currentAttr = {name: '', value: ''}\n}\n\n/**\n * Set current location.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Point | undefined} point\n *   Point.\n * @returns {undefined}\n *   Nothing.\n */\nfunction setPoint(state, point) {\n  if (point && point.offset !== undefined) {\n    /** @type {Token.Location} */\n    const location = {\n      startLine: point.line,\n      startCol: point.column,\n      startOffset: point.offset,\n      endLine: -1,\n      endCol: -1,\n      endOffset: -1\n    }\n\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.tokenizer.preprocessor.lineStartPos = -point.column + 1 // Looks weird, but ensures we get correct positional info.\n    state.parser.tokenizer.preprocessor.droppedBufferSize = point.offset\n    state.parser.tokenizer.preprocessor.line = point.line\n    // @ts-expect-error: private.\n    state.parser.tokenizer.currentLocation = location\n  }\n}\n\n/**\n * Emit a start tag.\n *\n * @param {Element} node\n *   Element.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */\nfunction startTag(node, state) {\n  const tagName = node.tagName.toLowerCase()\n\n  // Ignore tags if we’re in plain text.\n  if (state.parser.tokenizer.state === TokenizerMode.PLAINTEXT) return\n\n  resetTokenizer(state, pointStart(node))\n\n  const current = state.parser.openElements.current\n  let ns = 'namespaceURI' in current ? current.namespaceURI : webNamespaces.html\n\n  if (ns === webNamespaces.html && tagName === 'svg') {\n    ns = webNamespaces.svg\n  }\n\n  const result = toParse5(\n    // Shallow clone to not delve into `children`: we only need the attributes.\n    {...node, children: []},\n    {space: ns === webNamespaces.svg ? 'svg' : 'html'}\n  )\n\n  /** @type {Token.TagToken} */\n  const tag = {\n    type: Token.TokenType.START_TAG,\n    tagName,\n    tagID: html.getTagID(tagName),\n    // We always send start and end tags.\n    selfClosing: false,\n    ackSelfClosing: false,\n    // Always element.\n    /* c8 ignore next */\n    attrs: 'attrs' in result ? result.attrs : [],\n    location: createParse5Location(node)\n  }\n\n  // The HTML parsing algorithm works by doing half of the state management in\n  // the tokenizer and half in the parser.\n  // We can’t use the tokenizer here, as we don’t have strings.\n  // So we act *as if* the tokenizer emits tokens:\n\n  // @ts-expect-error: private.\n  state.parser.currentToken = tag\n  // @ts-expect-error: private.\n  state.parser._processToken(state.parser.currentToken)\n\n  // …but then we still need a bunch of work that the tokenizer would normally\n  // do, such as:\n\n  // Set a tag name, similar to how the tokenizer would do it.\n  state.parser.tokenizer.lastStartTagName = tagName\n\n  // `inForeignNode` is correctly set by the parser.\n}\n\n/**\n * Emit an end tag.\n *\n * @param {Element} node\n *   Element.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */\nfunction endTag(node, state) {\n  const tagName = node.tagName.toLowerCase()\n  // Do not emit closing tags for HTML void elements.\n  if (\n    !state.parser.tokenizer.inForeignNode &&\n    htmlVoidElements.includes(tagName)\n  ) {\n    return\n  }\n\n  // Ignore tags if we’re in plain text.\n  if (state.parser.tokenizer.state === TokenizerMode.PLAINTEXT) return\n\n  resetTokenizer(state, pointEnd(node))\n\n  /** @type {Token.TagToken} */\n  const tag = {\n    type: Token.TokenType.END_TAG,\n    tagName,\n    tagID: html.getTagID(tagName),\n    selfClosing: false,\n    ackSelfClosing: false,\n    attrs: [],\n    location: createParse5Location(node)\n  }\n\n  // The HTML parsing algorithm works by doing half of the state management in\n  // the tokenizer and half in the parser.\n  // We can’t use the tokenizer here, as we don’t have strings.\n  // So we act *as if* the tokenizer emits tokens:\n\n  // @ts-expect-error: private.\n  state.parser.currentToken = tag\n  // @ts-expect-error: private.\n  state.parser._processToken(state.parser.currentToken)\n\n  // …but then we still need a bunch of work that the tokenizer would normally\n  // do, such as:\n\n  // Switch back to the data state after alternative states that don’t accept\n  // tags:\n  if (\n    // Current element is closed.\n    tagName === state.parser.tokenizer.lastStartTagName &&\n    // `<textarea>` and `<title>`\n    (state.parser.tokenizer.state === TokenizerMode.RCDATA ||\n      // `<iframe>`, `<noembed>`, `<noframes>`, `<style>`, `<xmp>`\n      state.parser.tokenizer.state === TokenizerMode.RAWTEXT ||\n      // `<script>`\n      state.parser.tokenizer.state === TokenizerMode.SCRIPT_DATA)\n    // Note: `<plaintext>` not needed, as it’s the last element.\n  ) {\n    state.parser.tokenizer.state = TokenizerMode.DATA\n  }\n}\n\n/**\n * Check if `node` represents a whole document or a fragment.\n *\n * @param {Nodes} node\n *   hast node.\n * @returns {boolean}\n *   Whether this represents a whole document or a fragment.\n */\nfunction documentMode(node) {\n  const head = node.type === 'root' ? node.children[0] : node\n  return Boolean(\n    head &&\n      (head.type === 'doctype' ||\n        (head.type === 'element' && head.tagName.toLowerCase() === 'html'))\n  )\n}\n\n/**\n * Get a `parse5` location from a node.\n *\n * @param {Nodes | Stitch} node\n *   hast node.\n * @returns {Token.Location}\n *   `parse5` location.\n */\nfunction createParse5Location(node) {\n  const start = pointStart(node) || {\n    line: undefined,\n    column: undefined,\n    offset: undefined\n  }\n  const end = pointEnd(node) || {\n    line: undefined,\n    column: undefined,\n    offset: undefined\n  }\n\n  /** @type {Record<keyof Token.Location, number | undefined>} */\n  const location = {\n    startLine: start.line,\n    startCol: start.column,\n    startOffset: start.offset,\n    endLine: end.line,\n    endCol: end.column,\n    endOffset: end.offset\n  }\n\n  // @ts-expect-error: unist point values can be `undefined` in hast, which\n  // `parse5` types don’t want.\n  return location\n}\n\n/**\n * @template {Nodes} NodeType\n *   Node type.\n * @param {NodeType} node\n *   Node to clone.\n * @returns {NodeType}\n *   Cloned node, without children.\n */\nfunction cloneWithoutChildren(node) {\n  return 'children' in node\n    ? structuredClone({...node, children: []})\n    : structuredClone(node)\n}\n"],"names":["gfmTagfilterExpression","knownMdxNames","Set","parseOptions","sourceCodeLocationInfo","scriptingEnabled","raw","tree","options","document","node","head","type","children","Boolean","tagName","toLowerCase","documentMode","one","handlers","root","element","text","comment","doctype","handleRaw","unknown","state","parser","getFragmentParser","undefined","handle","stitches","resetTokenizer","p5","getFragment","result","file","index","parent","stitch","value","length","all","nodes","tokenizer","PLAINTEXT","current","openElements","ns","namespaceURI","html","svg","space","tag","START_TAG","tagID","selfClosing","ackSelfClosing","attrs","location","createParse5Location","currentToken","_processToken","lastStartTagName","startTag","inForeignNode","includes","END_TAG","RCDATA","RAWTEXT","SCRIPT_DATA","DATA","endTag","token","CHARACTER","chars","DOCTYPE","name","forceQuirks","publicId","systemId","clone","cloneWithoutChildren","fakeRoot","data","COMMENT","preprocessor","pos","lastGapPos","gapStack","skipNextNewLine","lastChunkWritten","endOfChunkHit","isEol","setPoint","write","tagfilter","replace","_runParsingLoop","cp","_consume","_callState","node_","passThrough","extra","has","Error","point","currentCharacterToken","endLine","line","endCol","col","endOffset","offset","paused","inLoop","active","returnState","charRefCode","consumedAfterSnapshot","currentLocation","currentAttr","startLine","startCol","column","startOffset","lineStartPos","droppedBufferSize","start","end"],"sourceRoot":""}