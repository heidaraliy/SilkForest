{"version":3,"file":"static/js/vendor.hast-util-to-parse5.9d57a8270225396cd2af.js","mappings":"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","sources":["webpack://silkforest-web/../../node_modules/hast-util-to-parse5/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Doctype} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n * @typedef {import('hast').Text} Text\n *\n * @typedef {import('parse5').DefaultTreeAdapterMap['document']} Parse5Document\n * @typedef {import('parse5').DefaultTreeAdapterMap['documentFragment']} Parse5Fragment\n * @typedef {import('parse5').DefaultTreeAdapterMap['element']} Parse5Element\n * @typedef {import('parse5').DefaultTreeAdapterMap['node']} Parse5Nodes\n * @typedef {import('parse5').DefaultTreeAdapterMap['documentType']} Parse5Doctype\n * @typedef {import('parse5').DefaultTreeAdapterMap['commentNode']} Parse5Comment\n * @typedef {import('parse5').DefaultTreeAdapterMap['textNode']} Parse5Text\n * @typedef {import('parse5').DefaultTreeAdapterMap['parentNode']} Parse5Parent\n * @typedef {import('parse5').Token.Attribute} Parse5Attribute\n *\n * @typedef {import('property-information').Schema} Schema\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {Space | null | undefined} [space='html']\n *   Which space the document is in (default: `'html'`).\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n *\n * @typedef {Exclude<Parse5Nodes, Parse5Document | Parse5Fragment>} Parse5Content\n *\n * @typedef {'html' | 'svg'} Space\n */\n\nimport {stringify as commas} from 'comma-separated-tokens'\nimport {ok as assert} from 'devlop'\nimport {find, html, svg} from 'property-information'\nimport {stringify as spaces} from 'space-separated-tokens'\nimport {webNamespaces} from 'web-namespaces'\nimport {zwitch} from 'zwitch'\n\n/** @type {Options} */\nconst emptyOptions = {}\n\nconst own = {}.hasOwnProperty\n\nconst one = zwitch('type', {handlers: {root, element, text, comment, doctype}})\n\n/**\n * Transform a hast tree to a `parse5` AST.\n *\n * @param {Nodes} tree\n *   Tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Parse5Nodes}\n *   `parse5` node.\n */\nexport function toParse5(tree, options) {\n  const settings = options || emptyOptions\n  const space = settings.space\n  return one(tree, space === 'svg' ? svg : html)\n}\n\n/**\n * @param {Root} node\n *   Node (hast) to transform.\n * @param {Schema} schema\n *   Current schema.\n * @returns {Parse5Document}\n *   Parse5 node.\n */\nfunction root(node, schema) {\n  /** @type {Parse5Document} */\n  const result = {\n    nodeName: '#document',\n    // @ts-expect-error: `parse5` uses enums, which are actually strings.\n    mode: (node.data || {}).quirksMode ? 'quirks' : 'no-quirks',\n    childNodes: []\n  }\n  result.childNodes = all(node.children, result, schema)\n  patch(node, result)\n  return result\n}\n\n/**\n * @param {Root} node\n *   Node (hast) to transform.\n * @param {Schema} schema\n *   Current schema.\n * @returns {Parse5Fragment}\n *   Parse5 node.\n */\nfunction fragment(node, schema) {\n  /** @type {Parse5Fragment} */\n  const result = {nodeName: '#document-fragment', childNodes: []}\n  result.childNodes = all(node.children, result, schema)\n  patch(node, result)\n  return result\n}\n\n/**\n * @param {Doctype} node\n *   Node (hast) to transform.\n * @returns {Parse5Doctype}\n *   Parse5 node.\n */\nfunction doctype(node) {\n  /** @type {Parse5Doctype} */\n  const result = {\n    nodeName: '#documentType',\n    name: 'html',\n    publicId: '',\n    systemId: '',\n    parentNode: null\n  }\n\n  patch(node, result)\n  return result\n}\n\n/**\n * @param {Text} node\n *   Node (hast) to transform.\n * @returns {Parse5Text}\n *   Parse5 node.\n */\nfunction text(node) {\n  /** @type {Parse5Text} */\n  const result = {\n    nodeName: '#text',\n    value: node.value,\n    parentNode: null\n  }\n  patch(node, result)\n  return result\n}\n\n/**\n * @param {Comment} node\n *   Node (hast) to transform.\n * @returns {Parse5Comment}\n *   Parse5 node.\n */\nfunction comment(node) {\n  /** @type {Parse5Comment} */\n  const result = {\n    nodeName: '#comment',\n    data: node.value,\n    parentNode: null\n  }\n\n  patch(node, result)\n\n  return result\n}\n\n/**\n * @param {Element} node\n *   Node (hast) to transform.\n * @param {Schema} schema\n *   Current schema.\n * @returns {Parse5Element}\n *   Parse5 node.\n */\nfunction element(node, schema) {\n  const parentSchema = schema\n  let currentSchema = parentSchema\n\n  if (\n    node.type === 'element' &&\n    node.tagName.toLowerCase() === 'svg' &&\n    parentSchema.space === 'html'\n  ) {\n    currentSchema = svg\n  }\n\n  /** @type {Array<Parse5Attribute>} */\n  const attrs = []\n  /** @type {string} */\n  let prop\n\n  if (node.properties) {\n    for (prop in node.properties) {\n      if (prop !== 'children' && own.call(node.properties, prop)) {\n        const result = createProperty(\n          currentSchema,\n          prop,\n          node.properties[prop]\n        )\n\n        if (result) {\n          attrs.push(result)\n        }\n      }\n    }\n  }\n\n  const space = currentSchema.space\n  // `html` and `svg` both have a space.\n  assert(space)\n\n  /** @type {Parse5Element} */\n  const result = {\n    nodeName: node.tagName,\n    tagName: node.tagName,\n    attrs,\n    // @ts-expect-error: `parse5` types are wrong.\n    namespaceURI: webNamespaces[space],\n    childNodes: [],\n    parentNode: null\n  }\n  result.childNodes = all(node.children, result, currentSchema)\n  patch(node, result)\n\n  if (node.tagName === 'template' && node.content) {\n    // @ts-expect-error: `parse5` types are wrong.\n    result.content = fragment(node.content, currentSchema)\n  }\n\n  return result\n}\n\n/**\n * Handle a property.\n *\n * @param {Schema} schema\n *   Current schema.\n * @param {string} prop\n *   Key.\n * @param {Array<number | string> | boolean | number | string | null | undefined} value\n *   hast property value.\n * @returns {Parse5Attribute | undefined}\n *   Field for runtime, optional.\n */\nfunction createProperty(schema, prop, value) {\n  const info = find(schema, prop)\n\n  // Ignore nullish and `NaN` values.\n  if (\n    value === false ||\n    value === null ||\n    value === undefined ||\n    (typeof value === 'number' && Number.isNaN(value)) ||\n    (!value && info.boolean)\n  ) {\n    return\n  }\n\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? commas(value) : spaces(value)\n  }\n\n  /** @type {Parse5Attribute} */\n  const attribute = {\n    name: info.attribute,\n    value: value === true ? '' : String(value)\n  }\n\n  if (info.space && info.space !== 'html' && info.space !== 'svg') {\n    const index = attribute.name.indexOf(':')\n\n    if (index < 0) {\n      attribute.prefix = ''\n    } else {\n      attribute.name = attribute.name.slice(index + 1)\n      attribute.prefix = info.attribute.slice(0, index)\n    }\n\n    attribute.namespace = webNamespaces[info.space]\n  }\n\n  return attribute\n}\n\n/**\n * Transform all hast nodes.\n *\n * @param {Array<RootContent>} children\n *   List of children.\n * @param {Parse5Parent} parentNode\n *   `parse5` parent node.\n * @param {Schema} schema\n *   Current schema.\n * @returns {Array<Parse5Content>}\n *   Transformed children.\n */\nfunction all(children, parentNode, schema) {\n  let index = -1\n  /** @type {Array<Parse5Content>} */\n  const results = []\n\n  if (children) {\n    while (++index < children.length) {\n      /** @type {Parse5Content} */\n      const child = one(children[index], schema)\n\n      child.parentNode = parentNode\n\n      results.push(child)\n    }\n  }\n\n  return results\n}\n\n/**\n * Add position info from `from` to `to`.\n *\n * @param {Nodes} from\n *   hast node.\n * @param {Parse5Nodes} to\n *   `parse5` node.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(from, to) {\n  const position = from.position\n\n  if (position && position.start && position.end) {\n    assert(typeof position.start.offset === 'number')\n    assert(typeof position.end.offset === 'number')\n\n    to.sourceCodeLocation = {\n      startLine: position.start.line,\n      startCol: position.start.column,\n      startOffset: position.start.offset,\n      endLine: position.end.line,\n      endCol: position.end.column,\n      endOffset: position.end.offset\n    }\n  }\n}\n"],"names":["emptyOptions","own","hasOwnProperty","one","handlers","root","node","schema","result","nodeName","mode","data","quirksMode","childNodes","all","children","patch","element","parentSchema","currentSchema","type","tagName","toLowerCase","space","attrs","prop","properties","call","createProperty","push","namespaceURI","parentNode","content","fragment","text","value","comment","doctype","name","publicId","systemId","toParse5","tree","options","info","Number","isNaN","boolean","Array","isArray","commaSeparated","attribute","String","index","indexOf","prefix","slice","namespace","results","length","child","from","to","position","start","end","offset","sourceCodeLocation","startLine","line","startCol","column","startOffset","endLine","endCol","endOffset"],"sourceRoot":""}