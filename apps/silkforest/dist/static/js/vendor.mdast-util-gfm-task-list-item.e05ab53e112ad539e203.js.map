{"version":3,"file":"static/js/vendor.mdast-util-gfm-task-list-item.e05ab53e112ad539e203.js","mappings":"iKAoBO,SAASA,IACd,MAAO,CACLC,KAAM,CACJC,0BAA2BC,EAC3BC,4BAA6BD,EAC7BE,UAAWC,GAGjB,CASO,SAASC,IACd,MAAO,CACLC,OAAQ,CAAC,CAACC,SAAS,EAAMC,UAAW,IAAKC,MAAO,UAChDC,SAAU,CAACC,SAAUC,GAEzB,CAMA,SAASX,EAAUY,GAEjB,MAAMC,EAAOC,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,IAC5C,QAAqB,aAAdH,EAAKI,MACZJ,EAAKK,QAAyB,8BAAfN,EAAMK,IACvB,CAMA,SAASd,EAA8BS,GACrC,MAAMO,EAASL,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAE9C,GACEG,GACgB,aAAhBA,EAAOF,MACmB,kBAAnBE,EAAOD,QACd,CACA,MAAML,EAAOC,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,IAC5C,QAAqB,cAAdH,EAAKI,MACZ,MAAMG,EAAOP,EAAKQ,SAAS,GAE3B,GAAID,GAAsB,SAAdA,EAAKH,KAAiB,CAChC,MAAMK,EAAWH,EAAOE,SACxB,IAEIE,EAFAC,GAAS,EAIb,OAASA,EAAQF,EAASN,QAAQ,CAChC,MAAMS,EAAUH,EAASE,GACzB,GAAqB,cAAjBC,EAAQR,KAAsB,CAChCM,EAAkBE,EAClB,KACF,CACF,CAEIF,IAAoBV,IAEtBO,EAAKM,MAAQN,EAAKM,MAAMC,MAAM,GAEJ,IAAtBP,EAAKM,MAAMV,OACbH,EAAKQ,SAASO,QAEdf,EAAKgB,UACLT,EAAKS,UACiC,iBAA/BT,EAAKS,SAASC,MAAMC,SAE3BX,EAAKS,SAASC,MAAME,SACpBZ,EAAKS,SAASC,MAAMC,SACpBlB,EAAKgB,SAASC,MAAQG,OAAOC,OAAO,CAAC,EAAGd,EAAKS,SAASC,QAG5D,CACF,CAEAhB,KAAKhB,KAAKc,EACZ,CAMA,SAASD,EAAyBE,EAAMM,EAAQgB,EAAOC,GACrD,MAAMhB,EAAOP,EAAKQ,SAAS,GACrBgB,EACoB,kBAAjBxB,EAAKK,SAAyBE,GAAsB,cAAdA,EAAKH,KAC9CqB,EAAW,KAAOzB,EAAKK,QAAU,IAAM,KAAO,KAC9CqB,EAAUJ,EAAMK,cAAcJ,GAEhCC,GACFE,EAAQE,KAAKH,GAGf,IAAIZ,EAAQ,IAAgBhB,SAASG,EAAMM,EAAQgB,EAAO,IACrDC,KACAG,EAAQG,YAOb,OAJIL,IACFX,EAAQA,EAAMiB,QAAQ,mCASxB,SAAeC,GACb,OAAOA,EAAKN,CACd,KAROZ,CAST,C","sources":["webpack://silkforest-web/../../node_modules/mdast-util-gfm-task-list-item/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\nimport {ok as assert} from 'devlop'\nimport {defaultHandlers} from 'mdast-util-to-markdown'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM task\n * list items in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM task list items.\n */\nexport function gfmTaskListItemFromMarkdown() {\n  return {\n    exit: {\n      taskListCheckValueChecked: exitCheck,\n      taskListCheckValueUnchecked: exitCheck,\n      paragraph: exitParagraphWithTaskListItem\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM task list\n * items in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM task list items.\n */\nexport function gfmTaskListItemToMarkdown() {\n  return {\n    unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],\n    handlers: {listItem: listItemWithTaskListItem}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCheck(token) {\n  // Weâ€™re always in a paragraph, in a list item.\n  const node = this.stack[this.stack.length - 2]\n  assert(node.type === 'listItem')\n  node.checked = token.type === 'taskListCheckValueChecked'\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitParagraphWithTaskListItem(token) {\n  const parent = this.stack[this.stack.length - 2]\n\n  if (\n    parent &&\n    parent.type === 'listItem' &&\n    typeof parent.checked === 'boolean'\n  ) {\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'paragraph')\n    const head = node.children[0]\n\n    if (head && head.type === 'text') {\n      const siblings = parent.children\n      let index = -1\n      /** @type {Paragraph | undefined} */\n      let firstParaghraph\n\n      while (++index < siblings.length) {\n        const sibling = siblings[index]\n        if (sibling.type === 'paragraph') {\n          firstParaghraph = sibling\n          break\n        }\n      }\n\n      if (firstParaghraph === node) {\n        // Must start with a space or a tab.\n        head.value = head.value.slice(1)\n\n        if (head.value.length === 0) {\n          node.children.shift()\n        } else if (\n          node.position &&\n          head.position &&\n          typeof head.position.start.offset === 'number'\n        ) {\n          head.position.start.column++\n          head.position.start.offset++\n          node.position.start = Object.assign({}, head.position.start)\n        }\n      }\n    }\n  }\n\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {ListItem} node\n */\nfunction listItemWithTaskListItem(node, parent, state, info) {\n  const head = node.children[0]\n  const checkable =\n    typeof node.checked === 'boolean' && head && head.type === 'paragraph'\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '\n  const tracker = state.createTracker(info)\n\n  if (checkable) {\n    tracker.move(checkbox)\n  }\n\n  let value = defaultHandlers.listItem(node, parent, state, {\n    ...info,\n    ...tracker.current()\n  })\n\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\n  }\n\n  return value\n\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n  function check($0) {\n    return $0 + checkbox\n  }\n}\n"],"names":["gfmTaskListItemFromMarkdown","exit","taskListCheckValueChecked","exitCheck","taskListCheckValueUnchecked","paragraph","exitParagraphWithTaskListItem","gfmTaskListItemToMarkdown","unsafe","atBreak","character","after","handlers","listItem","listItemWithTaskListItem","token","node","this","stack","length","type","checked","parent","head","children","siblings","firstParaghraph","index","sibling","value","slice","shift","position","start","offset","column","Object","assign","state","info","checkable","checkbox","tracker","createTracker","move","current","replace","$0"],"sourceRoot":""}