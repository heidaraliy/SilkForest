{"version":3,"file":"static/js/vendor.micromark-extension-gfm-task-list-item.c15f41500348f1fe25aa.js","mappings":"yJAMA,MAAMA,EAAgB,CACpBC,KAAM,gBACNC,SAuBF,SAA+BC,EAASC,EAAIC,GAC1C,MAAMC,EAAOC,KACb,OAYA,SAAcC,GACZ,GAEkB,OAAlBF,EAAKG,WAGJH,EAAKI,mCACJ,OAAOL,EAAIG,GAMb,OAJAL,EAAQQ,MAAM,iBACdR,EAAQQ,MAAM,uBACdR,EAAQS,QAAQJ,GAChBL,EAAQU,KAAK,uBACNC,CACT,EAYA,SAASA,EAAON,GAId,OAAI,QAA0BA,IAC5BL,EAAQQ,MAAM,+BACdR,EAAQS,QAAQJ,GAChBL,EAAQU,KAAK,+BACNE,GAEI,KAATP,GAAwB,MAATA,GACjBL,EAAQQ,MAAM,6BACdR,EAAQS,QAAQJ,GAChBL,EAAQU,KAAK,6BACNE,GAEFV,EAAIG,EACb,CAYA,SAASO,EAAMP,GACb,OAAa,KAATA,GACFL,EAAQQ,MAAM,uBACdR,EAAQS,QAAQJ,GAChBL,EAAQU,KAAK,uBACbV,EAAQU,KAAK,iBACNG,GAEFX,EAAIG,EACb,CAKA,SAASQ,EAAMR,GAEb,OAAI,QAAmBA,GACdJ,EAAGI,IAKR,QAAcA,GACTL,EAAQc,MAAM,CACnBf,SAAUgB,GACTd,EAAIC,EAFAF,CAEKK,GAIPH,EAAIG,EACb,CACF,GAhHO,SAASW,IACd,MAAO,CACLC,KAAM,CACJ,GAAMpB,GAGZ,CAgHA,SAASkB,EAAkBf,EAASC,EAAIC,GACtC,OAAO,OAAaF,GAYpB,SAAeK,GAKb,OAAgB,OAATA,EAAgBH,EAAIG,GAAQJ,EAAGI,EACxC,GAlBoC,aAmBtC,C","sources":["webpack://silkforest-web/../../node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js"],"sourcesContent":["/**\n * @import {Extension, State, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\nconst tasklistCheck = {\n  name: 'tasklistCheck',\n  tokenize: tokenizeTasklistCheck\n};\n\n/**\n * Create an HTML extension for `micromark` to support GFM task list items\n * syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\n *   support GFM task list items when serializing to HTML.\n */\nexport function gfmTaskListItem() {\n  return {\n    text: {\n      [91]: tasklistCheck\n    }\n  };\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  const self = this;\n  return open;\n\n  /**\n   * At start of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (\n    // Exit if there’s stuff before.\n    self.previous !== null ||\n    // Exit if not in the first content that is the first child of a list\n    // item.\n    !self._gfmTasklistFirstContentOfListItem) {\n      return nok(code);\n    }\n    effects.enter('taskListCheck');\n    effects.enter('taskListCheckMarker');\n    effects.consume(code);\n    effects.exit('taskListCheckMarker');\n    return inside;\n  }\n\n  /**\n   * In task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    // Currently we match how GH works in files.\n    // To match how GH works in comments, use `markdownSpace` (`[\\t ]`) instead\n    // of `markdownLineEndingOrSpace` (`[\\t\\n\\r ]`).\n    if (markdownLineEndingOrSpace(code)) {\n      effects.enter('taskListCheckValueUnchecked');\n      effects.consume(code);\n      effects.exit('taskListCheckValueUnchecked');\n      return close;\n    }\n    if (code === 88 || code === 120) {\n      effects.enter('taskListCheckValueChecked');\n      effects.consume(code);\n      effects.exit('taskListCheckValueChecked');\n      return close;\n    }\n    return nok(code);\n  }\n\n  /**\n   * At close of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function close(code) {\n    if (code === 93) {\n      effects.enter('taskListCheckMarker');\n      effects.consume(code);\n      effects.exit('taskListCheckMarker');\n      effects.exit('taskListCheck');\n      return after;\n    }\n    return nok(code);\n  }\n\n  /**\n   * @type {State}\n   */\n  function after(code) {\n    // EOL in paragraph means there must be something else after it.\n    if (markdownLineEnding(code)) {\n      return ok(code);\n    }\n\n    // Space or tab?\n    // Check what comes after.\n    if (markdownSpace(code)) {\n      return effects.check({\n        tokenize: spaceThenNonSpace\n      }, ok, nok)(code);\n    }\n\n    // EOF, or non-whitespace, both wrong.\n    return nok(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction spaceThenNonSpace(effects, ok, nok) {\n  return factorySpace(effects, after, \"whitespace\");\n\n  /**\n   * After whitespace, after task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // EOF means there was nothing, so bad.\n    // EOL means there’s content after it, so good.\n    // Impossible to have more spaces.\n    // Anything else is good.\n    return code === null ? nok(code) : ok(code);\n  }\n}"],"names":["tasklistCheck","name","tokenize","effects","ok","nok","self","this","code","previous","_gfmTasklistFirstContentOfListItem","enter","consume","exit","inside","close","after","check","spaceThenNonSpace","gfmTaskListItem","text"],"sourceRoot":""}