{"version":3,"file":"static/js/vendor.fast-equals.571fe624374218fb74fc.js","mappings":"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","sources":["webpack://silkforest-web/../../node_modules/fast-equals/dist/esm/index.mjs"],"sourcesContent":["var getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * Combine two comparators into a single comparators.\n */\nfunction combineComparators(comparatorA, comparatorB) {\n    return function isEqual(a, b, state) {\n        return comparatorA(a, b, state) && comparatorB(a, b, state);\n    };\n}\n/**\n * Wrap the provided `areItemsEqual` method to manage the circular state, allowing\n * for circular references to be safely included in the comparison without creating\n * stack overflows.\n */\nfunction createIsCircular(areItemsEqual) {\n    return function isCircular(a, b, state) {\n        if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\n            return areItemsEqual(a, b, state);\n        }\n        var cache = state.cache;\n        var cachedA = cache.get(a);\n        var cachedB = cache.get(b);\n        if (cachedA && cachedB) {\n            return cachedA === b && cachedB === a;\n        }\n        cache.set(a, b);\n        cache.set(b, a);\n        var result = areItemsEqual(a, b, state);\n        cache.delete(a);\n        cache.delete(b);\n        return result;\n    };\n}\n/**\n * Get the properties to strictly examine, which include both own properties that are\n * not enumerable and symbol properties.\n */\nfunction getStrictProperties(object) {\n    return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));\n}\n/**\n * Whether the object contains the property passed as an own property.\n */\nvar hasOwn = Object.hasOwn ||\n    (function (object, property) {\n        return hasOwnProperty.call(object, property);\n    });\n/**\n * Whether the values passed are strictly equal or both NaN.\n */\nfunction sameValueZeroEqual(a, b) {\n    return a || b ? a === b : a === b || (a !== a && b !== b);\n}\n\nvar OWNER = '_owner';\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, keys = Object.keys;\n/**\n * Whether the arrays are equal in value.\n */\nfunction areArraysEqual(a, b, state) {\n    var index = a.length;\n    if (b.length !== index) {\n        return false;\n    }\n    while (index-- > 0) {\n        if (!state.equals(a[index], b[index], index, index, a, b, state)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the dates passed are equal in value.\n */\nfunction areDatesEqual(a, b) {\n    return sameValueZeroEqual(a.getTime(), b.getTime());\n}\n/**\n * Whether the `Map`s are equal in value.\n */\nfunction areMapsEqual(a, b, state) {\n    if (a.size !== b.size) {\n        return false;\n    }\n    var matchedIndices = {};\n    var aIterable = a.entries();\n    var index = 0;\n    var aResult;\n    var bResult;\n    while ((aResult = aIterable.next())) {\n        if (aResult.done) {\n            break;\n        }\n        var bIterable = b.entries();\n        var hasMatch = false;\n        var matchIndex = 0;\n        while ((bResult = bIterable.next())) {\n            if (bResult.done) {\n                break;\n            }\n            var _a = aResult.value, aKey = _a[0], aValue = _a[1];\n            var _b = bResult.value, bKey = _b[0], bValue = _b[1];\n            if (!hasMatch &&\n                !matchedIndices[matchIndex] &&\n                (hasMatch =\n                    state.equals(aKey, bKey, index, matchIndex, a, b, state) &&\n                        state.equals(aValue, bValue, aKey, bKey, a, b, state))) {\n                matchedIndices[matchIndex] = true;\n            }\n            matchIndex++;\n        }\n        if (!hasMatch) {\n            return false;\n        }\n        index++;\n    }\n    return true;\n}\n/**\n * Whether the objects are equal in value.\n */\nfunction areObjectsEqual(a, b, state) {\n    var properties = keys(a);\n    var index = properties.length;\n    if (keys(b).length !== index) {\n        return false;\n    }\n    var property;\n    // Decrementing `while` showed faster results than either incrementing or\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\n    // methods like `some` / `every` were not used to avoid incurring the garbage\n    // cost of anonymous callbacks.\n    while (index-- > 0) {\n        property = properties[index];\n        if (property === OWNER &&\n            (a.$$typeof || b.$$typeof) &&\n            a.$$typeof !== b.$$typeof) {\n            return false;\n        }\n        if (!hasOwn(b, property) ||\n            !state.equals(a[property], b[property], property, property, a, b, state)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the objects are equal in value with strict property checking.\n */\nfunction areObjectsEqualStrict(a, b, state) {\n    var properties = getStrictProperties(a);\n    var index = properties.length;\n    if (getStrictProperties(b).length !== index) {\n        return false;\n    }\n    var property;\n    var descriptorA;\n    var descriptorB;\n    // Decrementing `while` showed faster results than either incrementing or\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\n    // methods like `some` / `every` were not used to avoid incurring the garbage\n    // cost of anonymous callbacks.\n    while (index-- > 0) {\n        property = properties[index];\n        if (property === OWNER &&\n            (a.$$typeof || b.$$typeof) &&\n            a.$$typeof !== b.$$typeof) {\n            return false;\n        }\n        if (!hasOwn(b, property)) {\n            return false;\n        }\n        if (!state.equals(a[property], b[property], property, property, a, b, state)) {\n            return false;\n        }\n        descriptorA = getOwnPropertyDescriptor(a, property);\n        descriptorB = getOwnPropertyDescriptor(b, property);\n        if ((descriptorA || descriptorB) &&\n            (!descriptorA ||\n                !descriptorB ||\n                descriptorA.configurable !== descriptorB.configurable ||\n                descriptorA.enumerable !== descriptorB.enumerable ||\n                descriptorA.writable !== descriptorB.writable)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the primitive wrappers passed are equal in value.\n */\nfunction arePrimitiveWrappersEqual(a, b) {\n    return sameValueZeroEqual(a.valueOf(), b.valueOf());\n}\n/**\n * Whether the regexps passed are equal in value.\n */\nfunction areRegExpsEqual(a, b) {\n    return a.source === b.source && a.flags === b.flags;\n}\n/**\n * Whether the `Set`s are equal in value.\n */\nfunction areSetsEqual(a, b, state) {\n    if (a.size !== b.size) {\n        return false;\n    }\n    var matchedIndices = {};\n    var aIterable = a.values();\n    var aResult;\n    var bResult;\n    while ((aResult = aIterable.next())) {\n        if (aResult.done) {\n            break;\n        }\n        var bIterable = b.values();\n        var hasMatch = false;\n        var matchIndex = 0;\n        while ((bResult = bIterable.next())) {\n            if (bResult.done) {\n                break;\n            }\n            if (!hasMatch &&\n                !matchedIndices[matchIndex] &&\n                (hasMatch = state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state))) {\n                matchedIndices[matchIndex] = true;\n            }\n            matchIndex++;\n        }\n        if (!hasMatch) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the TypedArray instances are equal in value.\n */\nfunction areTypedArraysEqual(a, b) {\n    var index = a.length;\n    if (b.length !== index) {\n        return false;\n    }\n    while (index-- > 0) {\n        if (a[index] !== b[index]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvar ARGUMENTS_TAG = '[object Arguments]';\nvar BOOLEAN_TAG = '[object Boolean]';\nvar DATE_TAG = '[object Date]';\nvar MAP_TAG = '[object Map]';\nvar NUMBER_TAG = '[object Number]';\nvar OBJECT_TAG = '[object Object]';\nvar REG_EXP_TAG = '[object RegExp]';\nvar SET_TAG = '[object Set]';\nvar STRING_TAG = '[object String]';\nvar isArray = Array.isArray;\nvar isTypedArray = typeof ArrayBuffer === 'function' && ArrayBuffer.isView\n    ? ArrayBuffer.isView\n    : null;\nvar assign = Object.assign;\nvar getTag = Object.prototype.toString.call.bind(Object.prototype.toString);\n/**\n * Create a comparator method based on the type-specific equality comparators passed.\n */\nfunction createEqualityComparator(_a) {\n    var areArraysEqual = _a.areArraysEqual, areDatesEqual = _a.areDatesEqual, areMapsEqual = _a.areMapsEqual, areObjectsEqual = _a.areObjectsEqual, arePrimitiveWrappersEqual = _a.arePrimitiveWrappersEqual, areRegExpsEqual = _a.areRegExpsEqual, areSetsEqual = _a.areSetsEqual, areTypedArraysEqual = _a.areTypedArraysEqual;\n    /**\n     * compare the value of the two objects and return true if they are equivalent in values\n     */\n    return function comparator(a, b, state) {\n        // If the items are strictly equal, no need to do a value comparison.\n        if (a === b) {\n            return true;\n        }\n        // If the items are not non-nullish objects, then the only possibility\n        // of them being equal but not strictly is if they are both `NaN`. Since\n        // `NaN` is uniquely not equal to itself, we can use self-comparison of\n        // both objects, which is faster than `isNaN()`.\n        if (a == null ||\n            b == null ||\n            typeof a !== 'object' ||\n            typeof b !== 'object') {\n            return a !== a && b !== b;\n        }\n        var constructor = a.constructor;\n        // Checks are listed in order of commonality of use-case:\n        //   1. Common complex object types (plain object, array)\n        //   2. Common data values (date, regexp)\n        //   3. Less-common complex object types (map, set)\n        //   4. Less-common data values (promise, primitive wrappers)\n        // Inherently this is both subjective and assumptive, however\n        // when reviewing comparable libraries in the wild this order\n        // appears to be generally consistent.\n        // Constructors should match, otherwise there is potential for false positives\n        // between class and subclass or custom object and POJO.\n        if (constructor !== b.constructor) {\n            return false;\n        }\n        // `isPlainObject` only checks against the object's own realm. Cross-realm\n        // comparisons are rare, and will be handled in the ultimate fallback, so\n        // we can avoid capturing the string tag.\n        if (constructor === Object) {\n            return areObjectsEqual(a, b, state);\n        }\n        // `isArray()` works on subclasses and is cross-realm, so we can avoid capturing\n        // the string tag or doing an `instanceof` check.\n        if (isArray(a)) {\n            return areArraysEqual(a, b, state);\n        }\n        // `isTypedArray()` works on all possible TypedArray classes, so we can avoid\n        // capturing the string tag or comparing against all possible constructors.\n        if (isTypedArray != null && isTypedArray(a)) {\n            return areTypedArraysEqual(a, b, state);\n        }\n        // Try to fast-path equality checks for other complex object types in the\n        // same realm to avoid capturing the string tag. Strict equality is used\n        // instead of `instanceof` because it is more performant for the common\n        // use-case. If someone is subclassing a native class, it will be handled\n        // with the string tag comparison.\n        if (constructor === Date) {\n            return areDatesEqual(a, b, state);\n        }\n        if (constructor === RegExp) {\n            return areRegExpsEqual(a, b, state);\n        }\n        if (constructor === Map) {\n            return areMapsEqual(a, b, state);\n        }\n        if (constructor === Set) {\n            return areSetsEqual(a, b, state);\n        }\n        // Since this is a custom object, capture the string tag to determing its type.\n        // This is reasonably performant in modern environments like v8 and SpiderMonkey.\n        var tag = getTag(a);\n        if (tag === DATE_TAG) {\n            return areDatesEqual(a, b, state);\n        }\n        if (tag === REG_EXP_TAG) {\n            return areRegExpsEqual(a, b, state);\n        }\n        if (tag === MAP_TAG) {\n            return areMapsEqual(a, b, state);\n        }\n        if (tag === SET_TAG) {\n            return areSetsEqual(a, b, state);\n        }\n        if (tag === OBJECT_TAG) {\n            // The exception for value comparison is custom `Promise`-like class instances. These should\n            // be treated the same as standard `Promise` objects, which means strict equality, and if\n            // it reaches this point then that strict equality comparison has already failed.\n            return (typeof a.then !== 'function' &&\n                typeof b.then !== 'function' &&\n                areObjectsEqual(a, b, state));\n        }\n        // If an arguments tag, it should be treated as a standard object.\n        if (tag === ARGUMENTS_TAG) {\n            return areObjectsEqual(a, b, state);\n        }\n        // As the penultimate fallback, check if the values passed are primitive wrappers. This\n        // is very rare in modern JS, which is why it is deprioritized compared to all other object\n        // types.\n        if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {\n            return arePrimitiveWrappersEqual(a, b, state);\n        }\n        // If not matching any tags that require a specific type of comparison, then we hard-code false because\n        // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\n        //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\n        //     comparison that can be made.\n        //   - For types that can be introspected, but rarely have requirements to be compared\n        //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\n        //     use-cases (may be included in a future release, if requested enough).\n        //   - For types that can be introspected but do not have an objective definition of what\n        //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\n        // In all cases, these decisions should be reevaluated based on changes to the language and\n        // common development practices.\n        return false;\n    };\n}\n/**\n * Create the configuration object used for building comparators.\n */\nfunction createEqualityComparatorConfig(_a) {\n    var circular = _a.circular, createCustomConfig = _a.createCustomConfig, strict = _a.strict;\n    var config = {\n        areArraysEqual: strict\n            ? areObjectsEqualStrict\n            : areArraysEqual,\n        areDatesEqual: areDatesEqual,\n        areMapsEqual: strict\n            ? combineComparators(areMapsEqual, areObjectsEqualStrict)\n            : areMapsEqual,\n        areObjectsEqual: strict\n            ? areObjectsEqualStrict\n            : areObjectsEqual,\n        arePrimitiveWrappersEqual: arePrimitiveWrappersEqual,\n        areRegExpsEqual: areRegExpsEqual,\n        areSetsEqual: strict\n            ? combineComparators(areSetsEqual, areObjectsEqualStrict)\n            : areSetsEqual,\n        areTypedArraysEqual: strict\n            ? areObjectsEqualStrict\n            : areTypedArraysEqual,\n    };\n    if (createCustomConfig) {\n        config = assign({}, config, createCustomConfig(config));\n    }\n    if (circular) {\n        var areArraysEqual$1 = createIsCircular(config.areArraysEqual);\n        var areMapsEqual$1 = createIsCircular(config.areMapsEqual);\n        var areObjectsEqual$1 = createIsCircular(config.areObjectsEqual);\n        var areSetsEqual$1 = createIsCircular(config.areSetsEqual);\n        config = assign({}, config, {\n            areArraysEqual: areArraysEqual$1,\n            areMapsEqual: areMapsEqual$1,\n            areObjectsEqual: areObjectsEqual$1,\n            areSetsEqual: areSetsEqual$1,\n        });\n    }\n    return config;\n}\n/**\n * Default equality comparator pass-through, used as the standard `isEqual` creator for\n * use inside the built comparator.\n */\nfunction createInternalEqualityComparator(compare) {\n    return function (a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {\n        return compare(a, b, state);\n    };\n}\n/**\n * Create the `isEqual` function used by the consuming application.\n */\nfunction createIsEqual(_a) {\n    var circular = _a.circular, comparator = _a.comparator, createState = _a.createState, equals = _a.equals, strict = _a.strict;\n    if (createState) {\n        return function isEqual(a, b) {\n            var _a = createState(), _b = _a.cache, cache = _b === void 0 ? circular ? new WeakMap() : undefined : _b, meta = _a.meta;\n            return comparator(a, b, {\n                cache: cache,\n                equals: equals,\n                meta: meta,\n                strict: strict,\n            });\n        };\n    }\n    if (circular) {\n        return function isEqual(a, b) {\n            return comparator(a, b, {\n                cache: new WeakMap(),\n                equals: equals,\n                meta: undefined,\n                strict: strict,\n            });\n        };\n    }\n    var state = {\n        cache: undefined,\n        equals: equals,\n        meta: undefined,\n        strict: strict,\n    };\n    return function isEqual(a, b) {\n        return comparator(a, b, state);\n    };\n}\n\n/**\n * Whether the items passed are deeply-equal in value.\n */\nvar deepEqual = createCustomEqual();\n/**\n * Whether the items passed are deeply-equal in value based on strict comparison.\n */\nvar strictDeepEqual = createCustomEqual({ strict: true });\n/**\n * Whether the items passed are deeply-equal in value, including circular references.\n */\nvar circularDeepEqual = createCustomEqual({ circular: true });\n/**\n * Whether the items passed are deeply-equal in value, including circular references,\n * based on strict comparison.\n */\nvar strictCircularDeepEqual = createCustomEqual({\n    circular: true,\n    strict: true,\n});\n/**\n * Whether the items passed are shallowly-equal in value.\n */\nvar shallowEqual = createCustomEqual({\n    createInternalComparator: function () { return sameValueZeroEqual; },\n});\n/**\n * Whether the items passed are shallowly-equal in value based on strict comparison\n */\nvar strictShallowEqual = createCustomEqual({\n    strict: true,\n    createInternalComparator: function () { return sameValueZeroEqual; },\n});\n/**\n * Whether the items passed are shallowly-equal in value, including circular references.\n */\nvar circularShallowEqual = createCustomEqual({\n    circular: true,\n    createInternalComparator: function () { return sameValueZeroEqual; },\n});\n/**\n * Whether the items passed are shallowly-equal in value, including circular references,\n * based on strict comparison.\n */\nvar strictCircularShallowEqual = createCustomEqual({\n    circular: true,\n    createInternalComparator: function () { return sameValueZeroEqual; },\n    strict: true,\n});\n/**\n * Create a custom equality comparison method.\n *\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\n * where the standard methods are not performant enough, but can also be used to provide\n * support for legacy environments that do not support expected features like\n * `RegExp.prototype.flags` out of the box.\n */\nfunction createCustomEqual(options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.circular, circular = _a === void 0 ? false : _a, createCustomInternalComparator = options.createInternalComparator, createState = options.createState, _b = options.strict, strict = _b === void 0 ? false : _b;\n    var config = createEqualityComparatorConfig(options);\n    var comparator = createEqualityComparator(config);\n    var equals = createCustomInternalComparator\n        ? createCustomInternalComparator(comparator)\n        : createInternalEqualityComparator(comparator);\n    return createIsEqual({ circular: circular, comparator: comparator, createState: createState, equals: equals, strict: strict });\n}\n\nexport { circularDeepEqual, circularShallowEqual, createCustomEqual, deepEqual, sameValueZeroEqual, shallowEqual, strictCircularDeepEqual, strictCircularShallowEqual, strictDeepEqual, strictShallowEqual };\n//# sourceMappingURL=index.mjs.map\n"],"names":["getOwnPropertyNames","Object","getOwnPropertySymbols","hasOwnProperty","prototype","combineComparators","comparatorA","comparatorB","a","b","state","createIsCircular","areItemsEqual","cache","cachedA","get","cachedB","set","result","delete","getStrictProperties","object","concat","hasOwn","property","call","sameValueZeroEqual","OWNER","getOwnPropertyDescriptor","keys","areArraysEqual","index","length","equals","areDatesEqual","getTime","areMapsEqual","size","aResult","bResult","matchedIndices","aIterable","entries","next","done","bIterable","hasMatch","matchIndex","_a","value","aKey","aValue","_b","bKey","bValue","areObjectsEqual","properties","$$typeof","areObjectsEqualStrict","descriptorA","descriptorB","configurable","enumerable","writable","arePrimitiveWrappersEqual","valueOf","areRegExpsEqual","source","flags","areSetsEqual","values","areTypedArraysEqual","isArray","Array","isTypedArray","ArrayBuffer","isView","assign","getTag","toString","bind","deepEqual","createCustomEqual","strict","circular","createInternalComparator","options","compare","createCustomInternalComparator","createState","config","createCustomConfig","areArraysEqual$1","areMapsEqual$1","areObjectsEqual$1","areSetsEqual$1","createEqualityComparatorConfig","comparator","constructor","Date","RegExp","Map","Set","tag","then","createEqualityComparator","WeakMap","undefined","meta","createIsEqual","_indexOrKeyA","_indexOrKeyB","_parentA","_parentB"],"sourceRoot":""}